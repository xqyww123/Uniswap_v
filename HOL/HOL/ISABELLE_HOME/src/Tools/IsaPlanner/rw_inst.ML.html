<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹~~/src/Tools/IsaPlanner/rw_inst.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹~~/src/Tools/IsaPlanner/rw_inst.ML›</h1>
</div>

<pre class="source"><span class="comment1"><span>(*  Title:      Tools/IsaPlanner/rw_inst.ML
    Author:     Lucas Dixon, University of Edinburgh

Rewriting using a conditional meta-equality theorem which supports
schematic variable instantiation.
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>RW_INST</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> rw</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span>
    </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>sort</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span> * </span><span class="comment1"><span>(* type var instantiations *)</span></span><span>
     </span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>typ</span><span> * </span><span>term</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(* schematic var instantiations *)</span></span><span>
    * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* Fake named bounds + types *)</span></span><span>
    * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* names of bound + types *)</span></span><span>
    * </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="comment1"><span>(* outer term for instantiation *)</span></span><span>
    </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="comment1"><span>(* rule with indexes lifted *)</span></span><span>
    </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="comment1"><span>(* target thm *)</span></span><span>
    </span><span>thm</span><span>  </span><span class="comment1"><span>(* rewritten theorem possibly with additional premises for rule conditions *)</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>RW_Inst</span></span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>RW_INST</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>

</span><span class="comment1"><span>(* Given (string,type) pairs capturing the free vars that need to be
allified in the assumption, and a theorem with assumptions possibly
containing the free vars, then we give back the assumptions allified
as hidden hyps.

Given: x
th: A vs ==&gt; B vs
Results in: "B vs" [!!x. A x]
*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>allify_conditions</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>allify</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>Logic.all_const</span><span> </span><span class="entity"><span>T</span></span><span> </span><span>$</span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>,</span></span><span> </span><span>Term.abstract_over</span><span> </span><span class="main"><span>(</span></span><span>Free</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cTs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>o</span><span> </span><span>Free</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cterm_asms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>o</span><span> </span><span>fold_rev</span><span> </span><span class="entity"><span>allify</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.prems_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>allifyied_asm_thms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Drule.forall_elim_list</span><span> </span><span class="entity"><span>cTs</span></span><span> </span><span>o</span><span> </span><span>Thm.assume</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>cterm_asms</span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span>fold</span><span> </span><span class="main"><span>(</span></span><span>curry</span><span> </span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span>COMP</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>allifyied_asm_thms</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>cterm_asms</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* Given a list of variables that were bound, and a that has been
instantiated with free variable placeholders for the bound vars, it
creates an abstracted version of the theorem, with local bound vars as
lambda-params:

Ts:
("x", ty)

rule::
C :x ==&gt; P :x = Q :x

results in:
("!! x. C x", (%x. p x = %y. p y) [!! x. C x])

note: assumes rule is instantiated
*)</span></span><span>
</span><span class="comment1"><span>(* Note, we take abstraction in the order of last abstraction first *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_abstractedrule</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>TsFake</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="comment1"><span>(* now we change the names of temporary free vars that represent
       bound vars with binders outside the redex *)</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ns</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>IsaND.variant_names</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.full_prop_of</span><span> </span><span class="entity"><span>rule</span></span><span> </span><span>::</span><span> </span><span>Thm.hyps_of</span><span> </span><span class="entity"><span>rule</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>fst</span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fromnames</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tonames</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>faken</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>n</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>n2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>rnf</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>rnt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts''</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
              </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Free</span><span class="main"><span>(</span></span><span class="entity"><span>faken</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>rnf</span></span><span class="main"><span>,</span></span><span>
               </span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Free</span><span class="main"><span>(</span></span><span class="entity"><span>n2</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>rnt</span></span><span class="main"><span>,</span></span><span>
               </span><span class="main"><span>(</span></span><span class="entity"><span>n2</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>Ts''</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="main"><span>(</span></span><span class="entity"><span>TsFake</span></span><span> </span><span>~~</span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span>~~</span><span> </span><span class="entity"><span>ns</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* rename conflicting free's in the rule to avoid cconflicts
    with introduced vars from bounds outside in redex *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rule'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>rule</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Drule.forall_intr_list</span><span> </span><span class="entity"><span>fromnames</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Drule.forall_elim_list</span><span> </span><span class="entity"><span>tonames</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* make unconditional rule and prems *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>uncond_rule</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>cprems</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>allify_conditions</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>rev</span><span> </span><span class="entity"><span>Ts'</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule'</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* using these names create lambda-abstracted version of the rule *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>abstractions</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Ts'</span></span><span> </span><span>~~</span><span> </span><span class="entity"><span>tonames</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>abstract_rule</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>n</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ct</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.abstract_rule</span><span> </span><span class="entity"><span>n</span></span><span> </span><span class="entity"><span>ct</span></span><span class="main"><span>)</span></span><span>
        </span><span class="entity"><span>abstractions</span></span><span> </span><span class="entity"><span>uncond_rule</span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>cprems</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>abstract_rule</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* given names to avoid, and vars that need to be fixed, it gives
unique new names to the vars so that they can be fixed as free
variables *)</span></span><span>
</span><span class="comment1"><span>(* make fixed unique free variable instantiations for non-ground vars *)</span></span><span>
</span><span class="comment1"><span>(* Create a table of vars to be renamed after instantiation - ie
      other uninstantiated vars in the hyps of the rule
      ie ?z in C ?z ?x ==&gt; A ?x ?y = B ?x ?y *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_renamings</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>tgt</span></span><span> </span><span class="entity"><span>rule_inst</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rule_conds</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.prems_of</span><span> </span><span class="entity"><span>rule_inst</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>cond_vs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tyvs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>vs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="main"><span>(</span></span><span>union</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Misc_Legacy.term_tvars</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>tyvs</span></span><span class="main"><span>,</span></span><span>
         </span><span>union</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>Term.dest_Var</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Misc_Legacy.term_vars</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vs</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule_conds</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>termvars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span>Term.dest_Var</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Misc_Legacy.term_vars</span></span><span> </span><span class="entity"><span>tgt</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars_to_fix</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>union</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>termvars</span></span><span> </span><span class="entity"><span>cond_vs</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ys</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>IsaND.variant_names</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tgt</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>rule_conds</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>fst</span><span> </span><span>o</span><span> </span><span>fst</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars_to_fix</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>map2</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>xi</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>y</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>xi</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Free</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars_to_fix</span></span><span> </span><span class="entity"><span>ys</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* make a new fresh typefree instantiation for the given tvar *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>new_tfree</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tv</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span class="entity"><span>sort</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>pairs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>used</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>singleton</span><span> </span><span class="main"><span>(</span></span><span>Name.variant_list</span><span> </span><span class="entity"><span>used</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>string_of_indexname</span><span> </span><span class="entity"><span>ix</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="entity"><span>sort</span></span><span class="main"><span>,</span></span><span>TFree</span><span class="main"><span>(</span></span><span class="entity"><span>v</span></span><span class="main"><span>,</span></span><span class="entity"><span>sort</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>::</span><span class="entity"><span>pairs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>v</span></span><span>::</span><span class="entity"><span>used</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* make instantiations to fix type variables that are not
   already instantiated (in ignore_ixs) from the list of terms. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_fixtvar_tyinsts</span></span><span> </span><span class="entity"><span>ignore_insts</span></span><span> </span><span class="entity"><span>ts</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ignore_ixs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span>fst</span><span> </span><span class="entity"><span>ignore_insts</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tvars</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tfrees</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold_rev</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>varixs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tfrees</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="main"><span>(</span></span><span class="entity"><span>Misc_Legacy.add_term_tvars</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>t</span></span><span class="main"><span>,</span></span><span class="entity"><span>varixs</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
         </span><span class="entity"><span>Misc_Legacy.add_term_tfrees</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>t</span></span><span class="main"><span>,</span></span><span class="entity"><span>tfrees</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ts</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>unfixed_tvars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>filter</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span class="entity"><span>s</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>not</span><span> </span><span class="main"><span>(</span></span><span>member</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ignore_ixs</span></span><span> </span><span class="entity"><span>ix</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>tvars</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fixtyinsts</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>fold_rev</span><span> </span><span class="entity"><span>new_tfree</span></span><span> </span><span class="entity"><span>unfixed_tvars</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span>map</span><span> </span><span>fst</span><span> </span><span class="entity"><span>tfrees</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fixtyinsts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tfrees</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* cross-instantiate the instantiations - ie for each instantiation
replace all occurrences in other instantiations - no loops are possible
and thus only one-parsing of the instantiations is necessary. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cross_inst</span></span><span> </span><span class="entity"><span>insts</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix2</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="entity"><span>ty2</span></span><span class="main"><span>,</span></span><span class="entity"><span>t2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="main"><span>(</span></span><span class="entity"><span>ix2</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ty2</span></span><span class="main"><span>,</span></span><span>Term.subst_vars</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>t2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="entity"><span>l</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* as above but for types -- I don't know if this is needed, will we ever incur mixed up types? *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cross_inst_typs</span></span><span> </span><span class="entity"><span>insts</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>srt</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix2</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="entity"><span>srt2</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix2</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>srt2</span></span><span class="main"><span>,</span></span><span>Term.typ_subst_TVars</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>ty2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="entity"><span>l</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>cross_instL</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* assume that rule and target_thm have distinct var names. THINK:
efficient version with tables for vars for: target vars, introduced
vars, and rule vars, for quicker instantiation?  The outerterm defines
which part of the target_thm was modified.  Note: we take Ts in the
upterm order, ie last abstraction first., and with an outeterm where
the abstracted subterm has the arguments in the revered order, ie
first abstraction first.  FakeTs has abstractions using the fake name
- ie the name distinct from all other abstractions. *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rw</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>nonfixed_typinsts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>unprepinsts</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>outerterm</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="entity"><span>target_thm</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="comment1"><span>(* fix all non-instantiated tvars *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fixtyinsts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>othertfrees</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="comment1"><span>(* FIXME proper context!? *)</span></span><span>
      </span><span class="entity"><span>mk_fixtvar_tyinsts</span></span><span> </span><span class="entity"><span>nonfixed_typinsts</span></span><span>
        </span><span class="main"><span>[</span></span><span>Thm.prop_of</span><span> </span><span class="entity"><span>rule</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.prop_of</span><span> </span><span class="entity"><span>target_thm</span></span><span class="main"><span>]</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>typinsts</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>cross_inst_typs</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>nonfixed_typinsts</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>fixtyinsts</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* certified instantiations for types *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ctyp_insts</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>TVars.make</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>s</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>typinsts</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* type instantiated versions *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tgt_th_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctyp_insts</span></span><span class="main"><span>,</span></span><span>Vars.empty</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>target_thm</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rule_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span>  </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctyp_insts</span></span><span class="main"><span>,</span></span><span>Vars.empty</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>term_typ_inst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>typinsts</span></span><span class="main"><span>;</span></span><span>
    </span><span class="comment1"><span>(* type instanitated outer term *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>outerterm_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.subst_TVars</span><span> </span><span class="entity"><span>term_typ_inst</span></span><span> </span><span class="entity"><span>outerterm</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>FakeTs_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span>Term.typ_subst_TVars</span><span> </span><span class="entity"><span>term_typ_inst</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>FakeTs</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>Ts_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span>Term.typ_subst_TVars</span><span> </span><span class="entity"><span>term_typ_inst</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* type-instantiate the var instantiations *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>insts_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold_rev</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>insts_tyinst</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span>Term.typ_subst_TVars</span><span> </span><span class="entity"><span>term_typ_inst</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span> </span><span>Term.subst_TVars</span><span> </span><span class="entity"><span>term_typ_inst</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
          </span><span>::</span><span> </span><span class="entity"><span>insts_tyinst</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>unprepinsts</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* cross-instantiate *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>insts_tyinst_inst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>cross_inst</span></span><span> </span><span class="entity"><span>insts_tyinst</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* create certms of instantiations *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cinsts_tyinst</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>Vars.make</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>insts_tyinst_inst</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* The instantiated rule *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rule_inst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>rule_tyinst</span></span><span> </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>cinsts_tyinst</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* Create a table of vars to be renamed after instantiation - ie
    other uninstantiated vars in the hyps the *instantiated* rule
    ie ?z in C ?z ?x ==&gt; A ?x ?y = B ?x ?y *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>renamings</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_renamings</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.prop_of</span><span> </span><span class="entity"><span>tgt_th_tyinst</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule_inst</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cterm_renamings</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>y</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>apply2</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Var</span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>y</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>renamings</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* Create the specific version of the rule for this target application *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>outerterm_inst</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>outerterm_tyinst</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Term.subst_Vars</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>insts_tyinst_inst</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Term.subst_Vars</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ix</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>renamings</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>couter_inst</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.reflexive</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>outerterm_inst</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>cprems</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>abstract_rule_inst</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>rule_inst</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span>Vars.make</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>apfst</span><span> </span><span class="main"><span>(</span></span><span>dest_Var</span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>cterm_renamings</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span class="entity"><span>mk_abstractedrule</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>FakeTs_tyinst</span></span><span> </span><span class="entity"><span>Ts_tyinst</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>specific_tgt_rule</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>Conv.fconv_rule</span><span> </span><span>Drule.beta_eta_conversion</span><span>
        </span><span class="main"><span>(</span></span><span>Thm.combination</span><span> </span><span class="entity"><span>couter_inst</span></span><span> </span><span class="entity"><span>abstract_rule_inst</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="comment1"><span>(* create an instantiated version of the target thm *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tgt_th_inst</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>tgt_th_tyinst</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>cinsts_tyinst</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span>Vars.make</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>apfst</span><span> </span><span class="main"><span>(</span></span><span>dest_Var</span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>cterm_renamings</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>vars</span></span><span class="main"><span>,</span></span><span class="entity"><span>frees_of_fixed_vars</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Library.split_list</span><span> </span><span class="entity"><span>cterm_renamings</span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span>Conv.fconv_rule</span><span> </span><span>Drule.beta_eta_conversion</span><span> </span><span class="entity"><span>tgt_th_inst</span></span><span>
    </span><span>|&gt;</span><span> </span><span>Thm.equal_elim</span><span> </span><span class="entity"><span>specific_tgt_rule</span></span><span>
    </span><span>|&gt;</span><span> </span><span>Drule.implies_intr_list</span><span> </span><span class="entity"><span>cprems</span></span><span>
    </span><span>|&gt;</span><span> </span><span>Drule.forall_intr_list</span><span> </span><span class="entity"><span>frees_of_fixed_vars</span></span><span>
    </span><span>|&gt;</span><span> </span><span>Drule.forall_elim_list</span><span> </span><span class="entity"><span>vars</span></span><span>
    </span><span>|&gt;</span><span> </span><span>Thm.varifyT_global'</span><span> </span><span class="main"><span>(</span></span><span>TFrees.make_set</span><span> </span><span class="entity"><span>othertfrees</span></span><span class="main"><span>)</span></span><span>
    </span><span>|-&gt;</span><span> </span><span>K</span><span> </span><span>Drule.zero_var_indexes</span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
</span></pre>
</body>

</html>