<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹~~/src/Tools/eqsubst.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹~~/src/Tools/eqsubst.ML›</h1>
</div>

<pre class="source"><span class="comment1"><span>(*  Title:      Tools/eqsubst.ML
    Author:     Lucas Dixon, University of Edinburgh

Perform a substitution using an equation.
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>EQSUBST</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>sort</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* type instantiations *)</span></span><span>
      * </span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>typ</span><span> * </span><span>term</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(* term instantiations *)</span></span><span>
    * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* fake named type abs env *)</span></span><span>
    * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* type abs env *)</span></span><span>
    * </span><span>term</span><span> </span><span class="comment1"><span>(* outer term *)</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="entity"><span>Proof.context</span></span><span>
    * </span><span>int</span><span> </span><span class="comment1"><span>(* maxidx *)</span></span><span>
    * </span><span class="entity"><span>Zipper.T</span></span><span> </span><span class="comment1"><span>(* focusterm to search under *)</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>datatype</span></span></span><span> </span><span>'a</span><span> </span><span class="entity"><span>skipseq</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>SkipMore</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> int </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SkipSeq</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>'a</span><span> Seq.seq Seq.seq

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> skip_first_asm_occs_search</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>(</span></span><span>'a</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'b</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'c</span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'a</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'b</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'c</span><span> </span><span class="entity"><span>skipseq</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> skip_first_occs_search</span><span class="main"><span>:</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>'a</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'b</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'c</span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'a</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'b</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'c</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> skipto_skipseq</span><span class="main"><span>:</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'a</span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>'a</span><span> </span><span class="entity"><span>skipseq</span></span><span>

  </span><span class="comment1"><span>(* tactics *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> eqsubst_asm_tac</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> eqsubst_asm_tac'</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span class="entity"><span>skipseq</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> eqsubst_tac</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span>
    </span><span>int</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="comment1"><span>(* list of occurrences to rewrite, use [0] for any *)</span></span><span>
    </span><span>thm</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> eqsubst_tac'</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span>Seq.seq</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(* search function *)</span></span><span>
    </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="comment1"><span>(* equation theorem to rewrite with *)</span></span><span>
    </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="comment1"><span>(* subgoal number in goal theorem *)</span></span><span>
    </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="comment1"><span>(* goal theorem *)</span></span><span>
    </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span> </span><span class="comment1"><span>(* rewritten goal theorem *)</span></span><span>

  </span><span class="comment1"><span>(* search for substitutions *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> valid_match_start</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Zipper.T</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>bool</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> search_lr_all</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Zipper.T</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Zipper.T</span></span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> search_lr_valid</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.T</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>bool</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Zipper.T</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Zipper.T</span></span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> searchf_lr_unify_all</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> searchf_lr_unify_valid</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> searchf_bt_unify_valid</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span>Seq.seq</span><span> </span><span>Seq.seq</span><span>
</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>EqSubst</span></span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>EQSUBST</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>

</span><span class="comment1"><span>(* changes object "=" to meta "==" which prepares a given rewrite rule *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prep_meta_eq</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>Simplifier.mksimps</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>#&gt;</span><span> </span><span>map</span><span> </span><span>Drule.zero_var_indexes</span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* make free vars into schematic vars with index zero *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>unfix_frees</span></span><span> </span><span class="entity"><span>frees</span></span><span> </span><span class="main"><span>=</span></span><span>
   </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="main"><span>(</span></span><span>Thm.forall_elim_var</span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>frees</span></span><span> </span><span>o</span><span> </span><span>Drule.forall_intr_list</span><span> </span><span class="entity"><span>frees</span></span><span class="main"><span>;</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>match</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>sort</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* type instantiations *)</span></span><span>
   * </span><span class="main"><span>(</span></span><span>indexname</span><span> * </span><span class="main"><span>(</span></span><span>typ</span><span> * </span><span>term</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>list</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(* term instantiations *)</span></span><span>
  * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* fake named type abs env *)</span></span><span>
  * </span><span class="main"><span>(</span></span><span>string</span><span> * </span><span>typ</span><span class="main"><span>)</span></span><span> </span><span>list</span><span> </span><span class="comment1"><span>(* type abs env *)</span></span><span>
  * </span><span>term</span><span class="main"><span>;</span></span><span> </span><span class="comment1"><span>(* outer term *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>Proof.context</span></span><span>
  * </span><span>int</span><span> </span><span class="comment1"><span>(* maxidx *)</span></span><span>
  * </span><span class="entity"><span>Zipper.T</span></span><span class="main"><span>;</span></span><span> </span><span class="comment1"><span>(* focusterm to search under *)</span></span><span>


</span><span class="comment1"><span>(* skipping non-empty sub-sequences but when we reach the end
   of the seq, remembering how much we have left to skip. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>datatype</span></span></span><span> </span><span>'a</span><span> </span><span class="entity"><span>skipseq</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>SkipMore</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> int </span><span class="main"><span>|</span></span><span>
  </span><span class="entity"><span>SkipSeq</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>'a</span><span> Seq.seq Seq.seq</span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* given a seqseq, skip the first m non-empty seq's, note deficit *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>skipto_skipseq</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>skip_occs</span></span><span> </span><span class="entity"><span>n</span></span><span> </span><span class="entity"><span>sq</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="entity"><span>sq</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
        </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>SkipMore</span></span><span> </span><span class="entity"><span>n</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="entity"><span>h</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
          </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>skip_occs</span></span><span> </span><span class="entity"><span>n</span></span><span> </span><span class="entity"><span>t</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>n</span></span><span> </span><span>&lt;=</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>SkipSeq</span></span><span> </span><span class="main"><span>(</span></span><span>Seq.cons</span><span> </span><span class="entity"><span>h</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>skip_occs</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>n</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>skip_occs</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* note: outerterm is the taget with the match replaced by a bound
   variable : ie: "P lhs" beocmes "%x. P x"
   insts is the types of instantiations of vars in lhs
   and typinsts is the type instantiations of types in the lhs
   Note: Final rule is the rule lifted into the ontext of the
   taget thm. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_foo_match</span></span><span> </span><span class="entity"><span>mkuptermfunc</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ty</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.type_of</span><span> </span><span class="entity"><span>t</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>bigtype</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>snd</span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>)</span></span><span> </span><span>---&gt;</span><span> </span><span class="entity"><span>ty</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_foo</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>t</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>mk_foo</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_foo</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>t</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Bound</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>num_of_bnds</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>length</span><span> </span><span class="entity"><span>Ts</span></span><span>
    </span><span class="comment1"><span>(* foo_term = "fooabs y0 ... yn" where y's are local bounds *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>foo_term</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_foo</span></span><span> </span><span class="entity"><span>num_of_bnds</span></span><span> </span><span class="main"><span>(</span></span><span>Bound</span><span> </span><span class="entity"><span>num_of_bnds</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"fooabs"</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>bigtype</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>mkuptermfunc</span></span><span> </span><span class="entity"><span>foo_term</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* T is outer bound vars, n is number of locally bound vars *)</span></span><span>
</span><span class="comment1"><span>(* THINK: is order of Ts correct...? or reversed? *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_fake_bound_name</span></span><span> </span><span class="entity"><span>n</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>":b_"</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>n</span></span><span class="main"><span>;</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>fakefree_badbounds</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>newnames</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span>fold_rev</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>n</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>usednames</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>newname</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>singleton</span><span> </span><span class="main"><span>(</span></span><span>Name.variant_list</span><span> </span><span class="entity"><span>usednames</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>n</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>mk_fake_bound_name</span></span><span> </span><span class="entity"><span>newname</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span>
          </span><span class="main"><span>(</span></span><span class="entity"><span>newname</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span>
          </span><span class="entity"><span>newname</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>usednames</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span>Term.subst_bounds</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>Free</span><span> </span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* before matching we need to fake the bound vars that are missing an
   abstraction. In this function we additionally construct the
   abstraction environment, and an outer context term (with the focus
   abstracted out) for use in rewriting with RW_Inst.rw *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prep_zipper_match</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>t</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Zipper.trm</span></span><span> </span><span class="entity"><span>z</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>c</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Zipper.ctxt</span></span><span> </span><span class="entity"><span>z</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Zipper.C.nty_ctxt</span></span><span> </span><span class="entity"><span>c</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>fakefree_badbounds</span></span><span> </span><span class="entity"><span>Ts</span></span><span> </span><span class="entity"><span>t</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>absterm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_foo_match</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.C.apply</span></span><span> </span><span class="entity"><span>c</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Ts'</span></span><span> </span><span class="entity"><span>t'</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>t'</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>absterm</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* Unification with exception handled *)</span></span><span>
</span><span class="comment1"><span>(* given context, max var index, pat, tgt; returns Seq of instantiations *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>clean_unify</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ix</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>a</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>pat</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tgt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="comment1"><span>(* type info will be re-derived, maybe this can be cached
       for efficiency? *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>pat_ty</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.type_of</span><span> </span><span class="entity"><span>pat</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tgt_ty</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.type_of</span><span> </span><span class="entity"><span>tgt</span></span><span class="main"><span>;</span></span><span>
    </span><span class="comment1"><span>(* FIXME is it OK to ignore the type instantiation info?
       or should I be using it? *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>typs_unify</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span>Sign.typ_unify</span><span> </span><span class="main"><span>(</span></span><span>Proof_Context.theory_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>pat_ty</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tgt_ty</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Vartab.empty</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ix</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>Type.TUNIFY</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>typs_unify</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
      </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>typinsttab</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ix2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
          </span><span class="comment1"><span>(* FIXME is it right to throw away the flexes?
             or should I be using them somehow? *)</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_insts</span></span><span> </span><span class="entity"><span>env</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="main"><span>(</span></span><span>Vartab.dest</span><span> </span><span class="main"><span>(</span></span><span>Envir.type_env</span><span> </span><span class="entity"><span>env</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
             </span><span>Vartab.dest</span><span> </span><span class="main"><span>(</span></span><span>Envir.term_env</span><span> </span><span class="entity"><span>env</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>initenv</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span>Envir.Envir</span><span> </span><span class="main"><span>{</span></span><span>maxidx</span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ix2</span></span><span class="main"><span>,</span></span><span> </span><span>tenv</span><span> </span><span class="main"><span>=</span></span><span> </span><span>Vartab.empty</span><span class="main"><span>,</span></span><span> </span><span>tyenv</span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>typinsttab</span></span><span class="main"><span>}</span></span><span class="main"><span>;</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>useq</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Unify.smash_unifiers</span><span> </span><span class="main"><span>(</span></span><span>Context.Proof</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>a</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>initenv</span></span><span>
            </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>ListPair.UnequalLengths</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.empty</span><span>
              </span><span class="main"><span>|</span></span><span> </span><span>Term.TERM</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.empty</span><span class="main"><span>;</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>clean_unify'</span></span><span> </span><span class="entity"><span>useq</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span>Seq.pull</span><span> </span><span class="entity"><span>useq</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
               </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span>
             </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>mk_insts</span></span><span> </span><span class="entity"><span>h</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clean_unify'</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>ListPair.UnequalLengths</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span>
              </span><span class="main"><span>|</span></span><span> </span><span>Term.TERM</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
          </span><span class="main"><span>(</span></span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clean_unify'</span></span><span> </span><span class="entity"><span>useq</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* Unification for zippers *)</span></span><span>
</span><span class="comment1"><span>(* Note: Ts is a modified version of the original names of the outer
   bound variables. New names have been introduced to make sure they are
   unique w.r.t all names in the term and each other. usednames' is
   oldnames + new names. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>clean_unify_z</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>maxidx</span></span><span> </span><span class="entity"><span>pat</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>t</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>absterm</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>prep_zipper_match</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>insts</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>insts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>FakeTs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>Ts</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>absterm</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>(</span></span><span class="entity"><span>clean_unify</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>maxidx</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>t</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>pat</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>l</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="entity"><span>l</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>t</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="entity"><span>t</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* Avoid considering replacing terms which have a var at the head as
   they always succeed trivially, and uninterestingly. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>valid_match_start</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>bot_left_leaf_of</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.trm</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
    </span><span>Var</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>true</span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* search from top, left to right, then down *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>search_lr_all</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ZipperSearch.all_bl_ur</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* search from top, left to right, then down *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>search_lr_valid</span></span><span> </span><span class="entity"><span>validf</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>sf_valid_td_lr</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>here</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>validf</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.Here</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>]</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>Zipper.trm</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
          </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_left</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>here</span></span><span> </span><span>@</span><span>
            </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_right</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>here</span></span><span> </span><span>@</span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_abs</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>here</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>Zipper.lzy_search</span></span><span> </span><span class="entity"><span>sf_valid_td_lr</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* search from bottom to top, left to right *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>search_bt_valid</span></span><span> </span><span class="entity"><span>validf</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>sf_valid_td_lr</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>here</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>validf</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.Here</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>]</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>Zipper.trm</span></span><span> </span><span class="entity"><span>z</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
          </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_left</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
             </span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_right</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>here</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>Zipper.LookIn</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_abs</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>here</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>here</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>Zipper.lzy_search</span></span><span> </span><span class="entity"><span>sf_valid_td_lr</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>searchf_unify_gen</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>maxidx</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>lhs</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clean_unify_z</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>maxidx</span></span><span> </span><span class="entity"><span>lhs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.limit_apply</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* search all unifications *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>searchf_lr_unify_all</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>searchf_unify_gen</span></span><span> </span><span class="entity"><span>search_lr_all</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* search only for 'valid' unifiers (non abs subterms and non vars) *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>searchf_lr_unify_valid</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>searchf_unify_gen</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>search_lr_valid</span></span><span> </span><span class="entity"><span>valid_match_start</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>searchf_bt_unify_valid</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>searchf_unify_gen</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>search_bt_valid</span></span><span> </span><span class="entity"><span>valid_match_start</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* apply a substitution in the conclusion of the theorem *)</span></span><span>
</span><span class="comment1"><span>(* cfvs are certified free var placeholders for goal params *)</span></span><span>
</span><span class="comment1"><span>(* conclthm is a theorem of for just the conclusion *)</span></span><span>
</span><span class="comment1"><span>(* m is instantiation/match information *)</span></span><span>
</span><span class="comment1"><span>(* rule is the equation for substitution *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>apply_subst_in_concl</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>cfvs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>conclthm</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>RW_Inst.rw</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="entity"><span>conclthm</span></span><span>
  </span><span>|&gt;</span><span> </span><span class="entity"><span>unfix_frees</span></span><span> </span><span class="entity"><span>cfvs</span></span><span>
  </span><span>|&gt;</span><span> </span><span>Conv.fconv_rule</span><span> </span><span>Drule.beta_eta_conversion</span><span>
  </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>r</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>resolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>r</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* substitute within the conclusion of goal i of gth, using a meta
equation rule. Note that we assume rule has var indicies zero'd *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prep_concl_subst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>gth</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.incr_indexes</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>gth</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tgt_term</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.prop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fixedbody</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>fvs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>IsaND.fix_alls_term</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>tgt_term</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cfvs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>fvs</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>conclterm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Logic.strip_imp_concl</span><span> </span><span class="entity"><span>fixedbody</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>conclthm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.trivial</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>conclterm</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>maxidx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.maxidx_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ft</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_right</span></span><span> </span><span class="comment1"><span>(* ==&gt; *)</span></span><span>
       </span><span>o</span><span> </span><span class="entity"><span>Zipper.move_down_left</span></span><span> </span><span class="comment1"><span>(* Trueprop *)</span></span><span>
       </span><span>o</span><span> </span><span class="entity"><span>Zipper.mktop</span></span><span>
       </span><span>o</span><span> </span><span>Thm.prop_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>conclthm</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>cfvs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>conclthm</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>maxidx</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ft</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* substitute using an object or meta level equality *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>eqsubst_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>instepthm</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>cvfsconclthm</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>prep_concl_subst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>stepthms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.of_list</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>prep_meta_eq</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>instepthm</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rewrite_with_thm</span></span><span> </span><span class="entity"><span>r</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lhs</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Logic.dest_equals</span><span> </span><span class="main"><span>(</span></span><span>Thm.concl_of</span><span> </span><span class="entity"><span>r</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="entity"><span>lhs</span></span><span>
        </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>apply_subst_in_concl</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="entity"><span>cvfsconclthm</span></span><span> </span><span class="entity"><span>r</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>stepthms</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="entity"><span>rewrite_with_thm</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* General substitution of multiple occurrences using one of
   the given theorems *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>skip_first_occs_search</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>srchf</span></span><span> </span><span class="entity"><span>sinfo</span></span><span> </span><span class="entity"><span>lhs</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>skipto_skipseq</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>srchf</span></span><span> </span><span class="entity"><span>sinfo</span></span><span> </span><span class="entity"><span>lhs</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
    </span><span class="entity"><span>SkipMore</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.empty</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SkipSeq</span></span><span> </span><span class="entity"><span>ss</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.flat</span><span> </span><span class="entity"><span>ss</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* The "occs" argument is a list of integers indicating which occurrence
w.r.t. the search order, to rewrite. Backtracking will also find later
occurrences, but all earlier ones are skipped. Thus you can use [0] to
just find all rewrites. *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>eqsubst_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>occs</span></span><span> </span><span class="entity"><span>thms</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>SELECT_GOAL</span><span>
    </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>thmseq</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.of_list</span><span> </span><span class="entity"><span>thms</span></span><span class="main"><span>;</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>apply_occ_tac</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span class="entity"><span>thmseq</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>r</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="entity"><span>eqsubst_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
            </span><span class="main"><span>(</span></span><span class="entity"><span>skip_first_occs_search</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>searchf_lr_unify_valid</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>r</span></span><span>
            </span><span class="main"><span>(</span></span><span>Thm.nprems_of</span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sorted_occs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Library.sort</span><span> </span><span class="main"><span>(</span></span><span>rev_order</span><span> </span><span>o</span><span> </span><span>int_ord</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>occs</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.EVERY</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="entity"><span>apply_occ_tac</span></span><span> </span><span class="entity"><span>sorted_occs</span></span><span class="main"><span>)</span></span><span> </span><span>#&gt;</span><span> </span><span>Seq.maps</span><span> </span><span>distinct_subgoals_tac</span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* apply a substitution inside assumption j, keeps asm in the same place *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>apply_subst_in_asm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>cfvs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>j</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>pth</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="entity"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>st2</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.rotate_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>j</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>;</span></span><span> </span><span class="comment1"><span>(* put premice first *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>preelimrule</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>RW_Inst.rw</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>rule</span></span><span> </span><span class="entity"><span>pth</span></span><span>
      </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span>Seq.hd</span><span> </span><span>o</span><span> </span><span>prune_params_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Thm.permute_prems</span><span> </span><span class="inner_numeral"><span>0</span></span><span> </span><span class="inner_numeral"><span>~1</span></span><span> </span><span class="comment1"><span>(* put old asm first *)</span></span><span>
      </span><span>|&gt;</span><span> </span><span class="entity"><span>unfix_frees</span></span><span> </span><span class="entity"><span>cfvs</span></span><span> </span><span class="comment1"><span>(* unfix any global params *)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Conv.fconv_rule</span><span> </span><span>Drule.beta_eta_conversion</span><span class="main"><span>;</span></span><span> </span><span class="comment1"><span>(* normal form *)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="comment1"><span>(* ~j because new asm starts at back, thus we subtract 1 *)</span></span><span>
    </span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span>Thm.rotate_rule</span><span> </span><span class="main"><span>(</span></span><span>~</span><span> </span><span class="entity"><span>j</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.nprems_of</span><span> </span><span class="entity"><span>rule</span></span><span> </span><span>+</span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>(</span></span><span>dresolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>preelimrule</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st2</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* prepare to substitute within the j'th premise of subgoal i of gth,
using a meta-level equation. Note that we assume rule has var indicies
zero'd. Note that we also assume that premt is the j'th premice of
subgoal i of gth. Note the repetition of work done for each
assumption, i.e. this can be made more efficient for search over
multiple assumptions.  *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prep_subst_in_asm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>gth</span></span><span> </span><span class="entity"><span>j</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.incr_indexes</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>gth</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tgt_term</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.prop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fixedbody</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>fvs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>IsaND.fix_alls_term</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>tgt_term</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cfvs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>rev</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>fvs</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asmt</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>nth</span><span> </span><span class="main"><span>(</span></span><span>Logic.strip_imp_prems</span><span> </span><span class="entity"><span>fixedbody</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>j</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_nprems</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>length</span><span> </span><span class="main"><span>(</span></span><span>Logic.strip_imp_prems</span><span> </span><span class="entity"><span>asmt</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>pth</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.trivial</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>asmt</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>maxidx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.maxidx_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>;</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ft</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="main"><span>(</span></span><span class="entity"><span>Zipper.move_down_right</span></span><span> </span><span class="comment1"><span>(* trueprop *)</span></span><span>
         </span><span>o</span><span> </span><span class="entity"><span>Zipper.mktop</span></span><span>
         </span><span>o</span><span> </span><span>Thm.prop_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>pth</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>cfvs</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>j</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>asm_nprems</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>pth</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>maxidx</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ft</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* prepare subst in every possible assumption *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prep_subst_in_asms</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>gth</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>prep_subst_in_asm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>gth</span></span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>l</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Library.upto</span><span> </span><span class="main"><span>(</span></span><span class="inner_numeral"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span>length</span><span> </span><span class="entity"><span>l</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>(</span></span><span>Logic.prems_of_goal</span><span> </span><span class="main"><span>(</span></span><span>Thm.prop_of</span><span> </span><span class="entity"><span>gth</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(* substitute in an assumption using an object or meta level equality *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>eqsubst_asm_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>skipocc</span></span><span> </span><span class="entity"><span>instepthm</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asmpreps</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>prep_subst_in_asms</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>stepthms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.of_list</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>prep_meta_eq</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>instepthm</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rewrite_with_thm</span></span><span> </span><span class="entity"><span>r</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lhs</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Logic.dest_equals</span><span> </span><span class="main"><span>(</span></span><span>Thm.concl_of</span><span> </span><span class="entity"><span>r</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>occ_search</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.empty</span><span>
          </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>occ_search</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>asminfo</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span class="main"><span>)</span></span><span>::</span><span class="entity"><span>moreasms</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>searchinfo</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>lhs</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
                </span><span class="entity"><span>SkipMore</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>occ_search</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>moreasms</span></span><span>
              </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SkipSeq</span></span><span> </span><span class="entity"><span>ss</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span>Seq.append</span><span> </span><span class="main"><span>(</span></span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span>Library.pair</span><span> </span><span class="entity"><span>asminfo</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Seq.flat</span><span> </span><span class="entity"><span>ss</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                    </span><span class="main"><span>(</span></span><span class="entity"><span>occ_search</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>moreasms</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(* find later substs also *)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="entity"><span>occ_search</span></span><span> </span><span class="entity"><span>skipocc</span></span><span> </span><span class="entity"><span>asmpreps</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>apply_subst_in_asm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="entity"><span>r</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>stepthms</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="entity"><span>rewrite_with_thm</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>skip_first_asm_occs_search</span></span><span> </span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>sinfo</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>lhs</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>skipto_skipseq</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>searchf</span></span><span> </span><span class="entity"><span>sinfo</span></span><span> </span><span class="entity"><span>lhs</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>eqsubst_asm_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>occs</span></span><span> </span><span class="entity"><span>thms</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>SELECT_GOAL</span><span>
    </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>thmseq</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.of_list</span><span> </span><span class="entity"><span>thms</span></span><span class="main"><span>;</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>apply_occ_tac</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span class="entity"><span>thmseq</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.maps</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>r</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="entity"><span>eqsubst_asm_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
            </span><span class="main"><span>(</span></span><span class="entity"><span>skip_first_asm_occs_search</span></span><span> </span><span class="entity"><span>searchf_lr_unify_valid</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>occ</span></span><span> </span><span class="entity"><span>r</span></span><span>
            </span><span class="main"><span>(</span></span><span>Thm.nprems_of</span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sorted_occs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Library.sort</span><span> </span><span class="main"><span>(</span></span><span>rev_order</span><span> </span><span>o</span><span> </span><span>int_ord</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>occs</span></span><span class="main"><span>;</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.EVERY</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="entity"><span>apply_occ_tac</span></span><span> </span><span class="entity"><span>sorted_occs</span></span><span class="main"><span>)</span></span><span> </span><span>#&gt;</span><span> </span><span>Seq.maps</span><span> </span><span>distinct_subgoals_tac</span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* combination method that takes a flag (true indicates that subst
   should be done to an assumption, false = apply to the conclusion of
   the goal) as well as the theorems to use *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>Theory.setup</span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>Method.setup</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="entity_def" id="HOL.subst|method"><span>subst</span></span><span>›</span></span></span><span>
      </span><span class="main"><span>(</span></span><span>Scan.lift</span><span> </span><span class="main"><span>(</span></span><span>Args.mode</span><span> </span><span class="inner_quoted"><span>"asm"</span></span><span> </span><span>--</span><span> </span><span>Scan.optional</span><span> </span><span class="main"><span>(</span></span><span>Args.parens</span><span> </span><span class="main"><span>(</span></span><span>Scan.repeat</span><span> </span><span>Parse.nat</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>[</span></span><span class="inner_numeral"><span>0</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span>--</span><span>
        </span><span class="entity"><span>Attrib.thms</span></span><span> </span><span>&gt;&gt;</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>asm</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>occs</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>inthms</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="entity"><span>SIMPLE_METHOD'</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>asm</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>eqsubst_asm_tac</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>eqsubst_tac</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>occs</span></span><span> </span><span class="entity"><span>inthms</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="inner_quoted"><span>"single-step substitution"</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
</span></pre>
</body>

</html>