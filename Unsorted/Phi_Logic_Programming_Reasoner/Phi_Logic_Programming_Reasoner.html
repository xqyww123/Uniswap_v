<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Phi_Logic_Programming_Reasoner</title>
</head>


<body>
<div class="head">
<h1>Theory Phi_Logic_Programming_Reasoner</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><a href="Phi_Logic_Programming_Reasoner.html"><span>Phi_Logic_Programming_Reasoner</span></a><span>
  </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="../../HOL/HOL/Main.html"><span>Main</span></a><span> </span><span class="quoted"><span>"</span><a href="HOL-Eisbach.Eisbach.html"><span>HOL-Eisbach.Eisbach</span></a><span>"</span></span><span> </span><span class="quoted"><span>"</span><a href="HOL-Eisbach.Eisbach_Tools.html"><span>HOL-Eisbach.Eisbach_Tools</span></a><span>"</span></span><span> </span><span class="quoted"><span>"</span><a href="Phi_Document.Base.html"><span>Phi_Document.Base</span></a><span>"</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>keywords</span></span></span><span> </span><span class="quoted"><span>"</span><span>except</span><span>"</span></span><span> </span><span class="quoted"><span>"</span><span>@action</span><span>"</span></span><span> </span><span class="main"><span>::</span></span><span> quasi_command
    </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span> </span><span class="quoted"><span>"</span><span>φreasoner</span><span>"</span></span><span> </span><span class="quoted"><span>"</span><span>φreasoner_ML</span><span>"</span></span><span> </span><span class="main"><span>::</span></span><span> thy_decl </span><span class="main"><span>%</span></span><span> </span><span class="quoted"><span>"</span><span>ML</span><span>"</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span> </span><span class="quoted"><span>"</span><span>print_φreasoners</span><span>"</span></span><span> </span><span class="main"><span>::</span></span><span> diag
  </span><span class="keyword2"><span class="keyword"><span>abbrevs</span></span></span><span>
      </span><span class="quoted"><span>"</span><span>&lt;premise&gt;</span><span>"</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>"</span><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span><span>"</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span> </span><span class="quoted"><span>"</span><span>&lt;simprem&gt;</span><span>"</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>"</span><span>𝗌𝗂𝗆𝗉𝗋𝖾𝗆</span><span>"</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span> </span><span class="quoted"><span>"</span><span>&lt;@GOAL&gt;</span><span>"</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>"</span><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span><span>"</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span> </span><span class="quoted"><span>"</span><span>&lt;threshold&gt;</span><span>"</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>"</span><span>𝗍𝗁𝗋𝖾𝗌𝗁𝗈𝗅𝖽</span><span>"</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Prelude Settings</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML</span></span></span><span> </span><span class="quoted"><span>‹</span><span>Timing.cond_timeit</span><span> </span><span>false</span><span> </span><span class="inner_quoted"><span>"asd"</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>OS.Process.sleep</span><span> </span><span class="main"><span>(</span></span><span>seconds</span><span> </span><span class="inner_numeral"><span>1.0</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/pattern.ML.html"><span>‹</span><span>library/pattern.ML</span><span>›</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/helpers.ML.html"><span>‹</span><span>library/helpers.ML</span><span>›</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/handlers.ML.html"><span>‹</span><span>library/handlers.ML</span><span>›</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/pattern_translation.ML.html"><span>‹</span><span>library/pattern_translation.ML</span><span>›</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>ML_file_debug</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/tools/simpset.ML.html"><span>‹</span><span>library/tools/simpset.ML</span><span>›</span></a></span><span>


</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require|const"><span>𝗋Require</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗋REQUIRE</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>2</span><span class="main"><span>]</span></span><span> 2</span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Require</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_action|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_action|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_action|axiom"><span>typedecl</span></span></span></span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.action|type"><span>action</span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>Action_Tag</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.action|type"><span>action</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span>_</span><span> </span><span class="keyword1"><span>@action</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>3</span><span class="main"><span>,</span></span><span>4</span><span class="main"><span>]</span></span><span> 3</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Action_Tag</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_I|thm"><span>Action_Tag_I</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>@action</span></a></span><span> </span><span class="free"><span>A</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file_debug</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html"><span>‹</span><span>library/reasoner.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_I|thm"><span>𝗋Require_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require|const"><span>𝗋Require</span></a><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Require_def|fact"><span>𝗋Require_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Introduction</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
  </span><span>φ-Logic Programming Reasoner is a extensible reasoning engine
</span><span>  based on logic programming like Prolog.
</span><span>  It allows arbitrary user reasoners to be integrated freely, and applies them selectively
</span><span>  by matching the pattern of the goals.
</span><span>
</span><span>  The reasoning is a depth-first heuristic search guided by </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>priority</span><span>›</span></span></span><span> of each branch.
</span><span>  A reasoning state is represented by a </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>pair</span><span>›</span></span></span><span> of </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Proof.context›</span></span></span><span> and a sequent, of type
</span><span>  </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Proof.context * thm›</span></span></span><span>.
</span><span>  Search branches on a reasoning state are admissible reasoners on the sequent.
</span><span>  A reasoner is admissible on a sequent if the sequent matches the pattern of the reasoner
</span><span>  (cf. patterns in \cref{sec:patterns}).
</span><span>
</span><span>  The reasoning accepts several reasoning states, and outputs </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>one</span><span>›</span></span></span><span> reasoning state which is the
</span><span>  first one satisfies the termination condition, </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>or</span><span>›</span></span></span><span> none if every search branches fail.
</span><span>
</span><span>  The priorities of rules demonstrate which rules are better among admissible reasoners.
</span><span>  The priority makes sense only locally, among all admissible reasoners on a reasoning state.
</span><span>  The accumulation of priority values (i.e. the sum of the priority of all applied reasoners) of a
</span><span>  reasoning state is meaningless and merely for debug-usage.
</span><span>  Because it is a DFS, the first reached result is the optimal one w.r.t each search branches in a
</span><span>  greedy sense. (the global maximum is senseless here because the priority accumulation is
</span><span>  meaningless).
</span><span>
</span><span>  The sequent of the reasoning state is a Harrop Formula (HF), e.g.,
</span><span>  \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Antecedent1 ⟹ Antecedent2 ⟹ Conclusion›</span></span></span><span>, \]
</span><span>  where antecedents represent sub-goals that have to be reasoned \textit{in order}.
</span><span>
</span><span>  The \xphi-LPR engine reasons antecedents in order, invoking the reasoners that match the pattern
</span><span>  of the leading antecedent best (cf. Priority).
</span><span>
</span><span>  An antecedent can be augmented by conditions that can be utilized during the reasoning.
</span><span>  It can also be universally quantified.
</span><span>  \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(⋀x. P1 x ⟹ P2 x ⟹ Conclusion_of_Antecedent1 x) ⟹ A2 ⟹ C›</span></span></span><span> \]
</span><span>
</span><span>  A typically reasoner is to deduce the conclusion of the antecedent by applying an introduction
</span><span>  rule like </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A11 x ⟹ A12 x ⟹ Conclusion_of_Antecedent1 x›</span></span></span><span>, resulting in
</span><span>  \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(⋀x. P1 x ⟹ P2 x ⟹ A11 x) ⟹ (⋀x. P11 x ⟹ P12 x ⟹ A12 x) ⟹ A2 ⟹ C›</span></span></span><span>. \]
</span><span>
</span><span>  Then, the engine reasons the currently heading antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(⋀x. P1 x ⟹ P2 x ⟹ A11 x)›</span></span></span><span>
</span><span>  recursively. The antecedent list of a reasoning state resembles a calling stack of usual programs.
</span><span>  From this perspective, the introduction rule of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>Antecedent1</span></span><span>›</span></span></span><span> invokes two 'sub-routines'
</span><span>  (or the reasoners of) </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>A11</span></span><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>A22</span></span><span>›</span></span></span><span>.</span><span>
  </span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The Engine \&amp; The Concepts</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>The engine is implemented in </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹library/reasoner.ML›</span></span></span><span>.
</span><span>
</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹structure Phi_Reasoner = struct

(*Reasoning state*)
type context_state = Proof.context * thm
type name = term (* the name as a term is just for pretty printing *)

val pattern_on_conclusion : term -&gt; pattern
val pattern_on_condition  : term -&gt; pattern

(*A reasoner is a quintuple*)
type reasoner = {
  name: name,
  pos: Position.T,
  pattern: pattern list,
  blacklist: pattern list,
  tactic: context_state -&gt; context_state Seq.seq
}

type priority = int
val add : priority * reasoner -&gt; Context.generic -&gt; Context.generic
val del : name -&gt; Context.generic -&gt; Context.generic
val reason : context_state -&gt; context_state option

val auto_level : int Config.T

exception Success of context_state
exception Global_Cut of context_state

...
end
›</span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Patterns \label{sec:patterns}</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>The </span><span class="antiquoted"><span class="operator"><span>❙</span></span><span class="plain_text"><span>‹</span><span>pattern</span><span>›</span></span></span><span> and the </span><span class="antiquoted"><span class="operator"><span>❙</span></span><span class="plain_text"><span>‹</span><span>blacklist</span><span>›</span></span></span><span> stipulate the range in which a reasoner will be invoked.
</span><span>A reasoner is invoked iff the antecedent matches at least one pattern in the pattern list and none
</span><span>  in the blacklist.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>There are two kinds of patterns, that match on conclusion and that on condition, constructed by
</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹pattern_on_conclusion›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹pattern_on_conclusion›</span></span></span><span> respectively.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span>❙</span></span><span class="plain_text"><span>‹</span><span>Prefix </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹var›</span></span></span><span>›</span></span></span><span>. A schematic variable in a pattern can have name prefix </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹var_›</span></span></span><span>.
</span><span>In this case, the variable only matches schematic variables.
</span><span>
</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Remark</span><span>›</span></span></span><span>: It is important to write schematic variables in patterns explicitly. The engine
</span><span>does not convert any free variables to schematic variables implicitly.</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Automatic Level</span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>by </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹auto_level›</span></span></span><span>
</span><span>is a general configuration deciding whether the engine applies</span><span>
  </span><span>some aggressive tactics that may consume considerable time or never terminate.</span><span>

</span><span>There are 3 levels:</span><span>
</span><span class="antiquoted"><span>▸</span></span><span>[0]: the most safe, which may mean manual mode for some reasoner.</span><span>
      </span><span>It does not exclude non-termination or blocking when some tactics are necessary for the</span><span>
      </span><span>features. Method </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>simp</span><span class="antiquote"><span>}</span></span></span><span> and </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/classical.ML.html#HOL.clarify|method"><span>clarify</span></a><span class="antiquote"><span>}</span></span></span><span> are acceptable on this level.</span><span>
</span><span class="antiquoted"><span>▸</span></span><span>[1]: relatively safe automation, where aggressive tactics are forbidden but non-termination is</span><span>
  </span><span>still possible. Method </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.auto|method"><span>auto</span></a><span class="antiquote"><span>}</span></span></span><span> is forbidden in this level because it blocks too easily.</span><span>
</span><span class="antiquoted"><span>▸</span></span><span>[2]: the most powerful automation, where no limitation is imposed on automation strategies.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Priority \label{sec:cut}</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>

</span><span>The reasoning is a depth-first search and every reasoner is registered with a priority deciding</span><span>
</span><span>the order of attempting the reasoners. Reasoners with higher priority are attempted first.</span><span>

</span><span>According to the priority of reasoners, reasoners fall into 3 sorts corresponding to</span><span>
</span><span>different pruning optimization strategy.</span><span>

</span><span class="antiquoted"><span>▸</span></span><span> </span><span>When the priorities of the candidate reasoners on a certain reasoning state are all less than 1000,</span><span>
  </span><span>the reasoning works in the normal behavior where it attempts the highest candidate and once fails</span><span>
  </span><span>backtracks to the next candidate.</span><span>

</span><span class="antiquoted"><span>▸</span></span><span> </span><span>When the highest priority of the candidates $\geq$ 1000 and $&lt;$ than 1000,000,</span><span>
  </span><span>this candidate becomes a </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>local cut</span><span>›</span></span></span><span>. The reasoning attempts only the local cut and if it fails,</span><span>
  </span><span>no other candidates will be attempted, but the backtrack is still propagated to the upper layer</span><span>
  </span><span>(of the search tree).</span><span>
  </span><span>Any presence of a candidate with priority $\geq$ 1000, causes the reasoning (at this point)</span><span>
  </span><span>is confident (in the sense that no alternative search branch will be attempted).</span><span>

</span><span class="antiquoted"><span>▸</span></span><span> </span><span>When the highest priority of the candidates $\geq$ 100,000,</span><span>
  </span><span>this candidate becomes a </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>global cut</span><span>›</span></span></span><span>, which forgets all the previous search history.</span><span>
  </span><span>No backtrack will be propagated to the past before the global cut so it improves the performance.</span><span>
  </span><span>Once the reasoning of the branch of the cut fails, the whole reasoning fails.</span><span>

</span><span>Reasoners of priority $\geq$ 1000 are named </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>confident reasoners</span><span>›</span></span></span><span> and others are</span><span>
</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>submissive reasoners</span><span>›</span></span></span><span>.</span><span>

</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Remark</span><span>›</span></span></span><span>: a local cut reasoner can throw </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Global_Cut s›</span></span></span><span> to trigger a global cut with the</span><span>
  </span><span>reasoning state </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹s›</span></span></span><span>.</span><span>

</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Termination</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The reasoning terminates when:</span><span>

</span><span class="antiquoted"><span>▪</span></span><span> </span><span>Any reasoning state has no antecedent any more or all its designated leading</span><span>
    </span><span>antecedents are solved. This reasoning state is returned.</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>Any reasoner throws </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Success result›</span></span></span><span>.</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>All accessible search paths are traversed.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Success›</span></span></span><span> is an antecedent that throws </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Success›</span></span></span><span>.
</span><span>Therefore it remarks the reasoning is succeeded.
</span><span>A typical usage of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Success›</span></span></span><span> is shown in the following sequent,
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A1 ⟹ A2 ⟹ 𝗋Success ⟹ P ⟹ Q›</span></span></span><span> \]
</span><span>which expresses the reasoning succeeds after solving </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>A1</span></span><span>›</span></span></span><span>, </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>A2</span></span><span>›</span></span></span><span>, and it outputs
</span><span>  result </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Pure.prop P›</span></span></span><span> is helpful to protect remaining antecedents if you only want to reason
</span><span>  the beginning several antecedents instead of all antecedents, e.g.,
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Solve_A1 ⟹ Pure.prop (Protect_A2 ⟹ C)›</span></span></span><span> \]</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Output</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The output reasoning state can be:</span><span>

</span><span class="antiquoted"><span>▪</span></span><span> </span><span>The first traversed reasoning state that has no antecedent or all the designated leading</span><span>
    </span><span>antecedents are solved.</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>The </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹result›</span></span></span><span> threw out by </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Success result›</span></span></span><span>.</span><span>

</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>If none of the above are reached during a reasoning process, the process returns nothing
</span><span>  (</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹None›</span></span></span><span> or </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Seq.empty›</span></span></span><span>).
</span><span>The reasoning only outputs </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>milestone states</span><span>›</span></span></span><span> representing the problem is indeed solved partially
</span><span>instead of any unfinished intermediate reasoning state.
</span><span>Milestone states are explicitly annotated by user (e.g.,
</span><span>  by antecedent </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>𝗋Success</span></span><span>›</span></span></span><span> or by setting the priority to 1000,000).
</span><span>Any other intermediate reasoning state is not considered a successfully finished state
</span><span>so that is not outputted.</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Provide User Reasoners \&amp; Apply the Engine</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>\xphi-LPR can be augmented by user reasoners.
</span><span>The system predefines a resolution based reasoner using introducing rules and elimination rules.
</span><span>Other arbitrary reasoners can also be built from tactics or ML code.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Reasoning by Rules</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Attributes </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute_def</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> is provided for introducing resolution rules.</span><span>

  </span><span>\begin{matharray}{rcl}</span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute_def</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> &amp; : &amp; </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>attribute›</span></span></span><span>
  </span><span>\end{matharray}</span><span>

  </span><span>\small</span><span>
  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span><span>‹
    </span><span class="keyword1"><span>@</span></span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> </span><span>(</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> add_rule</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="keyword3"><span>|</span></span><span> </span><span class="inner_quoted"><span>'add'</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> add_rule</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="keyword3"><span>|</span></span><span> </span><span class="inner_quoted"><span>'del'</span></span><span>)</span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax_def</span></span><span> add_rule</span><span class="antiquote"><span>}</span></span></span><span class="keyword2"><span>:</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> priority</span><span class="antiquote"><span>}</span></span></span><span class="keyword3"><span>?</span></span><span>
    </span><span>(</span><span class="inner_quoted"><span>'for'</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> patterns</span><span class="antiquote"><span>}</span></span></span><span>)</span><span class="keyword3"><span>?</span></span><span> </span><span>(</span><span class="inner_quoted"><span>'except'</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> blacklist</span><span class="antiquote"><span>}</span></span></span><span>)</span><span class="keyword3"><span>?</span></span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax_def</span></span><span> priority</span><span class="antiquote"><span>}</span></span></span><span class="keyword2"><span>:</span></span><span> </span><span>(</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> nat</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="keyword3"><span>|</span></span><span> </span><span class="inner_quoted"><span>'!'</span></span><span>)</span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax_def</span></span><span> patterns</span><span class="antiquote"><span>}</span></span></span><span class="keyword2"><span>:</span></span><span> </span><span>(</span><span>(</span><span>)</span><span> </span><span class="keyword3"><span>+</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> term</span><span class="antiquote"><span>}</span></span></span><span>)</span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax_def</span></span><span> blacklist</span><span class="antiquote"><span>}</span></span></span><span class="keyword2"><span>:</span></span><span> </span><span>(</span><span>(</span><span>)</span><span> </span><span class="keyword3"><span>+</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> term</span><span class="antiquote"><span>}</span></span></span><span>)</span><span>
  ›</span></span><span>
  </span><span>\normalsize</span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹add›</span></span></span><span> declares reasoning rules used in φ-LPR.</span><span>
  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹del›</span></span></span><span> removes the reasoning rule.</span><span>
  </span><span>If no keyword </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹add›</span></span></span><span> or </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹del›</span></span></span><span> is given, </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹add›</span></span></span><span> is the default option.</span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span>The </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> patterns</span><span class="antiquote"><span>}</span></span></span><span> and </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> blacklist</span><span class="antiquote"><span>}</span></span></span><span> are that described in \cref{sec:patterns}.</span><span>
  </span><span>For introduction rules, the patterns and the blacklist match only the conclusion of the</span><span>
  </span><span>leading antecedent; for elimination rules, they match only the conditions of the</span><span>
  </span><span>leading antecedent.</span><span>

  </span><span>Patterns can be omitted. For introduction rule, the default pattern is the conclusion</span><span>
  </span><span>of the rule; for elimination rule, the default is the first premise.</span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> priority</span><span class="antiquote"><span>}</span></span></span><span> can be a natural number or, an exclamation mark denoting the priority of</span><span>
  </span><span>1000,000, i.e., the minimal priority for a global cut.</span><span>
  </span><span>If the priority is not given explicitly, by default it is 100.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Remark</span><span>›</span></span></span><span>: Rules of priority $\geq$ 1000 are named </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>confident rules</span><span>›</span></span></span><span> and others are
</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>submissive rules</span><span>›</span></span></span><span>.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Remark</span><span>›</span></span></span><span>: Attribute </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>attribute</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> can be used without any argument.
</span><span>  </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹[[φreason]]›</span></span></span><span> denotes </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹[[φreason add]]›</span></span></span><span> exactly.
</span><span>  However, the usage of empty arguments is not recommended
</span><span>  due to technical reasons that in this case of empty argument
</span><span>  the attribute cannot get the position of the associated reasoning rule, and
</span><span>  this position is displayed in debug printing.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Example</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>declare</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conjI|fact"><span>conjI</span></a><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span>]</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.TrueI|fact"><span>TrueI</span></a><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋›</span></span></span><span>Feasible \label{sec:rFeasible}</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Cut rules including local cut and global cut are those of priority $\geq$ 1000.
</span><span>A cut rule can have at most one special </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Require›</span></span></span><span> antecedent at the leading position,
</span><span>which determines the condition of the rule to be applied, e.g. the following rule can be applied
</span><span>only if </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A1›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A2›</span></span></span><span> are solvable.
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Require (A1 &amp;&amp;&amp; A2) ⟹ A3 ⟹ C›</span></span></span><span> \]
</span><span>It provides a mechanism to constrain semantic conditions of applying the rule,
</span><span>whereas the pattern matches mentioned earlier are only able to check the syntactical conditions.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Reasoners by Isar Methods and ML code</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>There are two commands defining reasoners, respectively by Eisbach expression and by ML code.</span><span>

  </span><span>\begin{matharray}{rcl}</span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command_def</span></span><span> </span><span>φreasoner</span><span class="antiquote"><span>}</span></span></span><span> &amp; : &amp; </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>local_theory → local_theory›</span></span></span><span>\\</span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command_def</span></span><span> </span><span>φreasoner_ML</span><span class="antiquote"><span>}</span></span></span><span> &amp; : &amp; </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>local_theory → local_theory›</span></span></span><span>\\</span><span>
  </span><span>\end{matharray}</span><span>

  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span><span>‹
    </span><span class="keyword1"><span>@</span></span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>φreasoner</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> name</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> priority</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> patterns'</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="inner_quoted"><span>'='</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> Eisabach_method</span><span class="antiquote"><span>}</span></span></span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="keyword1"><span>@</span></span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>φreasoner_ML</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> name</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> priority</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> patterns'</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="inner_quoted"><span>'='</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> ML_code</span><span class="antiquote"><span>}</span></span></span><span>
    </span><span class="keyword2"><span>;</span></span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax_def</span></span><span> patterns'</span><span class="antiquote"><span>}</span></span></span><span class="keyword2"><span>:</span></span><span> </span><span class="inner_quoted"><span>'('</span></span><span> </span><span>(</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> term</span><span class="antiquote"><span>}</span></span></span><span> </span><span class="keyword3"><span>+</span></span><span> </span><span class="inner_quoted"><span>'¦'</span></span><span>)</span><span> </span><span class="inner_quoted"><span>')'</span></span><span>
  ›</span></span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>φreasoner</span><span class="antiquote"><span>}</span></span></span><span> defines a reasoner using an Eisabach expression. The Eisabach expression</span><span>
  </span><span>defines a proof method in Isabelle/Isar and this proof method is invoked on the leading antecedent</span><span>
  </span><span>as a sub-goal when </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> patterns'</span><span class="antiquote"><span>}</span></span></span><span> match.</span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>φreasoner_ML</span><span class="antiquote"><span>}</span></span></span><span> defines a reasoner from ML code. The given code should be a ML function</span><span>
  </span><span>of type </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹context_state -&gt; context_state Seq.seq›</span></span></span><span>, i.e., a contextual tactic.</span><span>

</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Apply the Engine</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>There are two ways to use the reasoning engine, from ML code by using </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹Phi_Reasoner.reason›</span></span></span><span>,
</span><span>and as a proof method.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Proof Method</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>There are two commands defining reasoners, respectively by Eisbach expression and by ML code.</span><span>

  </span><span>\begin{matharray}{rcl}</span><span>
    </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method_def</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|method"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> &amp; : &amp; </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>method›</span></span></span><span>\\</span><span>
  </span><span>\end{matharray}</span><span>

  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">rail</span><span class="hidden">&gt;</span></span></span><span>‹
    </span><span class="keyword1"><span>@</span></span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|method"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span> </span><span>(</span><span class="inner_quoted"><span>'add'</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> thms</span><span class="antiquote"><span>}</span></span></span><span>)</span><span class="keyword3"><span>?</span></span><span> </span><span>(</span><span class="inner_quoted"><span>'del'</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>syntax</span></span><span> thms</span><span class="antiquote"><span>}</span></span></span><span>)</span><span class="keyword3"><span>?</span></span><span>
  ›</span></span><span>

</span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|method"><span>φreason</span></a><span class="antiquote"><span>}</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹add›</span></span></span><span>~</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>a›</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹del›</span></span></span><span>~</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>b›</span></span></span><span>
  </span><span>applies φ-LPR on the proof state (which is a HHF sequent~\cite{isar-ref}).</span><span>
  </span><span>It means subgoals of the proof are regarded as antecedents and φ-LPR reasons them one by one</span><span>
  </span><span>in order.</span><span>

  </span><span>Optional modifier </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹add›</span></span></span><span>~</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>a›</span></span></span><span> adds introduction rules </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>a›</span></span></span><span> temporarily with default patterns</span><span>
  </span><span>(the conclusion of the rule) and default priority (100).</span><span>
  </span><span>Modifier </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹del›</span></span></span><span>~</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>b›</span></span></span><span> removes introductions rules </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>b›</span></span></span><span> temporarily.</span><span>
  </span><span>We do not provide modifiers to alter elimination rules now.</span><span>
</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Predefined Antecedents, Reasoners, and Rules</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Auxiliary Structures</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Isomorphic Atomize</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The system </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Object_Logic.atomize›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Object_Logic.rulify›</span></span></span><span> is not isomorphic in the sense
</span><span>  that for any given rule </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>R›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Object_Logic.rulify (Object_Logic.atomize R)›</span></span></span><span> does not exactly
</span><span>  equal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>R›</span></span></span><span>. The section gives a way addressing this issue.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html"><span>‹</span><span>library/iso_atomize.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_imp_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_imp_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_imp_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_imp_embed|const"><span>pure_imp_embed</span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>(⟶)</span></a></span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_all_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_all_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_all_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_all_embed|const"><span>pure_all_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>binder</span></span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span>∀<span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>m</sub><span class="hidden">⇩</span><sub>b</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>d</sub></span></span><span> </span><span>›</span></span><span> 10</span><span class="main"><span>)</span></span><span>
    </span><span class="comment1"><span>― ‹</span><span>We give it a binder syntax to prevent eta-contraction which
</span><span>        deprives names of quantifier variables</span><span>›</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>pure_all_embed</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>All</span></a><span class="main"><span>)</span></span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_conj_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_conj_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_conj_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_conj_embed|const"><span>pure_conj_embed</span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>(∧)</span></a></span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_prop_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_prop_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_prop_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.pure_prop_embed|const"><span>pure_prop_embed</span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>Q</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_imp_embed|const"><span>pure_imp_embed</span></a><span> </span><span class="free"><span>P</span></span><span> </span><span class="free"><span>Q</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_imp|fact"><span>atomize_imp</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_imp_embed_def|fact"><span>pure_imp_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><span>&amp;&amp;&amp;</span></span><span> </span><span class="free"><span>Q</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_conj_embed|const"><span>pure_conj_embed</span></a><span> </span><span class="free"><span>P</span></span><span> </span><span class="free"><span>Q</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_conj|fact"><span>atomize_conj</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_conj_embed_def|fact"><span>pure_conj_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>TODO: find a way to preserve the name</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_all_embed|const"><span>pure_all_embed</span></a><span> </span><span class="main"><span>(</span></span><span class="main"><span>λ</span></span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_all|fact"><span>atomize_all</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_all_embed_def|fact"><span>pure_all_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span>Pure.prop</span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_prop_embed|const"><span>pure_prop_embed</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><span>Pure.prop_def</span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.pure_prop_embed_def|fact"><span>pure_prop_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Action</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>In the reasoning, antecedents of the same form may have different purposes, e.g.,
</span><span>  antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P = ?Q›</span></span></span><span> may except a complete simplification or numeric calculation only or any other
</span><span>  specific conversion. Of different purposes, antecedents are expected to be processed by
</span><span>  different reasoners. To achieves this, because the engine selects reasoners by syntactic pattern,
</span><span>  this section proposes a general structure tagging the purpose of antecedents.
</span><span>
</span><span>The purpose is denoted by </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>action›</span></span></span><span> type, which is an unspecified type because it serves only for
</span><span>  syntactic purpose.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹P @action A››</span></span></span><span> tags antecedent </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> by the specific purpose denoted by </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>A</span></span><span>›</span></span></span><span>.
</span><span>
</span><span>  The type variable </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="tfree"><span>'category</span></span><span>›</span></span></span><span> enables to classify actions by types and type classes.
</span><span>  For example, some operation may be designed for any generic action </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?act :: (?'ty::cls) action›</span></span></span><span>
</span><span>  that fall into class </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>cls›</span></span></span><span>.
</span><span>
</span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Comment: I am thinking this category type variable is a bad design because the indexing
</span><span>  data structure (Net) we are using doesn't support type sort, causing this feature is actually
</span><span>  not indexed at all, causing the reasoning here becomes searching one by one in linear time!
</span><span>  Maybe classification should be done by some term-level structure. Let's think when have time!</span><span>›</span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_embed|const"><span>Action_Tag_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.action|type"><span>action</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Action_Tag_embed</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>Action_Tag</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_embed|const"><span>Action_Tag_embed</span></a><span> </span><span class="free"><span>P</span></span><span> </span><span class="free"><span>A</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_embed_def|fact"><span>Action_Tag_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_D|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Action_Tag_D|thm"><span>Action_Tag_D</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>@action</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Conv_Action_Tag_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Conv_Action_Tag_I|thm"><span>Conv_Action_Tag_I</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>X</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>X</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>@action</span></a></span><span> </span><span class="free"><span>A</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/action_tag.ML.html"><span>‹</span><span>library/action_tag.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Mode</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Modes are general annotations used in various antecedents, which may configure
</span><span>  for the specific reasoning behavior among slight different options.
</span><span>  The exact meaning of them depend on the specific antecedent using them.
</span><span>  An example can be found in \cref{sec:proof-obligation}.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>type_synonym</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.action|type"><span>action</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>We provide a serial of predefined modes, which may be commonly useful.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.default|const"><span>default</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.MODE_SIMP|const"><span>MODE_SIMP</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a></span><span> </span><span class="comment1"><span>― ‹</span><span>relating to simplification</span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.MODE_COLLECT|const"><span>MODE_COLLECT</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a></span><span> </span><span class="comment1"><span>― ‹</span><span>relating to collection</span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.MODE_AUTO|const"><span>MODE_AUTO</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a></span><span> </span><span class="comment1"><span>― ‹</span><span>something that will be triggered automatically</span><span>›</span></span><span>



</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>General Rules</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span>❙</span></span><span class="plain_text"><span>‹</span><span>Schematic variables</span><span>›</span></span></span><span> are able to be instantiated (assigned) by reasoners.
</span><span> The instantiation of an schematic variable </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?v›</span></span></span><span> updates all the occurrences of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?v›</span></span></span><span> in the
</span><span>  remaining sequent, and this instantion can be seen as assigning results of the execution of the
</span><span>  antecedent.
</span><span>For example,
</span><span> \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>1 + 2 = ?result ⟹ Print ?result ⟹ Done›</span></span></span><span> \]
</span><span>  the reasoning of antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>1 + 2 = ?result›</span></span></span><span> instantiates </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?result›</span></span></span><span> to </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>3›</span></span></span><span>, and results in
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Print 3 ⟹ Done›</span></span></span><span> \]
</span><span> If view the antecedent as a program (sub-routine),
</span><span> the schematic variables of the antecedent have a meaning of </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>output</span><span>›</span></span></span><span>,
</span><span> and we name them </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>output variables</span><span>›</span></span></span><span>.
</span><span>
</span><span>The following </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Try›</span></span></span><span> antecedent is a such example.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Try</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Try_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Try_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Try_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Try|const"><span>Try</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Try</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>success_or_fail</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>The typical usage is </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹Try ?success_or_fail P››</span></span></span><span>, where
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> should be an antecedent having some fallback reasoner (not given here),
</span><span>and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?success_or_fail›</span></span></span><span> is an output variable representing whether the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> is successfully
</span><span>deduced </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>without</span><span>›</span></span></span><span> using fallback.
</span><span>
</span><span>A high priority (800) rule reasons </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹Try True P››</span></span></span><span> normally and set the output variable
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>success_or_fail›</span></span></span><span> to be true.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 800 </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span>for</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><span>Try</span></a></a></a><span> </span><span class="var"><span class="var"><span class="var"><span>?S</span></span></span></span><span> </span><span class="var"><span class="var"><span class="var"><span>?P</span></span></span></span><span>›</span></span></span></span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="free"><span>P</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><span>Try</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try_def|fact"><span>Try_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>Users using </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹Try True P››</span></span></span><span> should provide the fallback rule for their own </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span>.
</span><span>It depends on the application scenario and there is not a general rule for fallback of course.
</span><span>The fallback rule may has the following form,
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> Fallback_of_P ⟹ Try False P ›</span></span></span><span> \]</span><span>
</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Compact Representation of Antecedents</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Meta-programming is feasible on φ-LPR.
</span><span>The reasoning of an antecedent may generate dynamically another antecedent, and assign it to
</span><span>an output variable of type </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>.
</span><span>
</span><span>When multiple antecedents are going to be generated, it is
</span><span>more efficient to contract them into one antecedent using conjunctions (e.g. </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A1 ∧ A2 ∧ A3 ∧ ⋯›</span></span></span><span>),
</span><span>so they can be represented by one output variable of type </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>.
</span><span>
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(∧<span class="hidden">⇩</span><sub>r</sub>)›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(∀<span class="hidden">⇩</span><sub>r</sub>)›</span></span></span><span> are used to contract antecedents and embed universally quantified variables
</span><span>respectively.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Antecedent_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Antecedent_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Antecedent_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Antecedent|const"><span>Compact_Antecedent</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>infixr</span></span></span><span> </span><span class="quoted"><span>"</span><span class="keyword1"><span>∧<span class="hidden">⇩</span><sub>𝗋</sub></span></span><span>"</span></span><span> 35</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Compact_Antecedent</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>(∧)</span></a></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Forall_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Forall_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Forall_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Compact_Forall|const"><span>Compact_Forall</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>binder</span></span></span><span> </span><span class="quoted"><span>"</span><span class="keyword1"><span>∀<span class="hidden">⇩</span><sub>𝗋</sub></span></span><span>"</span></span><span> 10</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Compact_Forall</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>All</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Assertive rules are given to unfold the compression and reason the antecedents in order.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>Q</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Compact_Antecedent|const"><span>∧<span class="hidden">⇩</span><sub>𝗋</sub></span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Compact_Antecedent_def|fact"><span>Compact_Antecedent_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Compact_Forall|const"><span>∀<span class="hidden">⇩</span><sub>𝗋</sub></span></a></span><span class="bound"><span>x</span></span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Compact_Forall|const"><span>.</span></a></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Compact_Forall_def|fact"><span>Compact_Forall_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>declare</span></span></span><span> </span><span>conjunctionI</span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span> </span><span class="comment1"><span>― ‹</span><span>Meta-conjunction </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P &amp;&amp;&amp; Q›</span></span></span><span> is also a compression.</span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Matches</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Antecedent </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>Matches</span></span><span> </span><span class="free"><span>pattern</span></span><span> </span><span class="free"><span>term</span></span><span>›</span></span></span><span> asserts </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>pattern</span></span><span>›</span></span></span><span> matches </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>term</span></span><span>›</span></span></span><span>;
</span><span>  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH|const"><span>NO_MATCH</span></a><span> </span><span class="free"><span>pattern</span></span><span> </span><span class="free"><span>term</span></span><span>›</span></span></span><span> asserts </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>pattern</span></span><span>›</span></span></span><span> does not match </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>term</span></span><span>›</span></span></span><span>.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches|const"><span>Matches</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Matches</span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Matches_I|thm"><span>Matches_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches|const"><span>Matches</span></a><span> </span><span class="free"><span>pattern</span></span><span> </span><span class="free"><span>term</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches_def|fact"><span>Matches_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches|const"><span>Matches</span></a></span><span> 2000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches|const"><span>Matches</span></a><span> </span><span class="var"><span>?pattern</span></span><span> </span><span class="var"><span>?term</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches|const"><span>Matches</span></a><span>›</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>pattern</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>term</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Pattern.matches</span><span> </span><span class="main"><span>(</span></span><span>Proof_Context.theory_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>pattern</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>term</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>Seq.single</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Matches_I|fact"><span>Matches_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Seq.empty</span><span>
    </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.NO_MATCH_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.NO_MATCH_I|thm"><span>NO_MATCH_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH|const"><span>NO_MATCH</span></a><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH_def|fact"><span>NO_MATCH_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH|const"><span>NO_MATCH</span></a></span><span> 0 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH|const"><span>NO_MATCH</span></a><span> </span><span class="var"><span>?A</span></span><span> </span><span class="var"><span>?B</span></span><span>"</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>
  </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.NO_MATCH|const"><span>NO_MATCH</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>a</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>th</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Pattern.matches</span><span> </span><span class="main"><span>(</span></span><span>Proof_Context.theory_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>a</span></span><span class="main"><span>,</span></span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>Seq.empty</span><span>
    </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Seq.single</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.NO_MATCH_I|fact"><span>NO_MATCH_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Proof By Assumption</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption|const"><span>By_Assumption</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>By_Assumption</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption|const"><span>May_By_Assumption</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>May_By_Assumption</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.By_Assumption_I|thm"><span>By_Assumption_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.By_Assumption|const"><span>By_Assumption</span></a><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.By_Assumption_def|fact"><span>By_Assumption_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.May_By_Assumption_I|thm"><span>May_By_Assumption_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.May_By_Assumption|const"><span>May_By_Assumption</span></a><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.May_By_Assumption_def|fact"><span>May_By_Assumption_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.By_Assumption|const"><span>By_Assumption</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.By_Assumption|const"><span>By_Assumption</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span>Tactic.assume_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.By_Assumption_I|fact"><span>By_Assumption_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span>pair</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.May_By_Assumption|const"><span>May_By_Assumption</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.May_By_Assumption|const"><span>May_By_Assumption</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sequent'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.May_By_Assumption_I|fact"><span>May_By_Assumption_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span>Tactic.assume_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span>ORELSE</span><span> </span><span>Seq.single</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>sequent'</span></span><span>
        </span><span>|&gt;</span><span> </span><span>Seq.map</span><span> </span><span class="main"><span>(</span></span><span>pair</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Cut</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The cuts have been introduced in \cref{sec:cut}.
</span><span>
</span><span>Antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Cut›</span></span></span><span> triggers a global cut.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut|const"><span>𝗋Cut</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Cut</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut|const"><span>𝗋Cut</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Cut_def|fact"><span>𝗋Cut_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Success›</span></span></span><span> terminates the reasoning successfully with the reasoning state as
</span><span>the result.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Success</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_I|thm"><span>𝗋Success_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_def|fact"><span>𝗋Success_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></a></span><span> 10000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Phi_Reasoner.Success</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success_I|fact"><span>𝗋Success_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Proof Obligation \&amp; Guard of Rule \label{sec:proof-obligation}</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Premise</span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>Normal_Premise</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>27</span><span class="main"><span>]</span></span><span> 26</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Normal_Premise</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.default|const"><span>default</span></a><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simp_Premise|const"><span>Simp_Premise</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗌𝗂𝗆𝗉𝗋𝖾𝗆</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>27</span><span class="main"><span>]</span></span><span> 26</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Simp_Premise</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.MODE_SIMP|const"><span>MODE_SIMP</span></a><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>Proof_Obligation</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>27</span><span class="main"><span>]</span></span><span> 26</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Proof_Obligation</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.MODE_COLLECT|const"><span>MODE_COLLECT</span></a><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> represents an ordinary proposition has to be proved during the reasoning.</span><span>
  </span><span>There are different modes expressing different roles in the reasoning.</span><span>

</span><span>  </span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simp_Premise|const"><span>𝗌𝗂𝗆𝗉𝗋𝖾𝗆</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> is a </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>guard</span><span>›</span></span></span><span> of a rule, which constrains that the rule is appliable only</span><span>
  </span><span>when </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> can be solved </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>automatically</span><span>›</span></span></span><span> during the reasoning.</span><span>
  </span><span>If </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> fails to be solved, even if it is actually valid, the rule will not be applied.</span><span>
  </span><span>Therefore, </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> has to be as simple as possible. The tactic used to solve </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> is</span><span>
  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.clarsimp|method"><span>clarsimp</span></a><span class="antiquote"><span>}</span></span></span><span>.</span><span>
  </span><span>A more powerful tactic like </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.auto|method"><span>auto</span></a><span class="antiquote"><span>}</span></span></span><span> is not adoptable because the tactic must be safe and</span><span>
  </span><span>non-blocking commonly.</span><span>
  </span><span>A blocking search branch blocks the whole reasoning, which is not acceptable.</span><span>

  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simp_Premise|const"><span>𝗌𝗂𝗆𝗉𝗋𝖾𝗆</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> is not for proof obligations that are intended to be solved by users.</span><span>
  </span><span>It is more like 'controller or switch' of the rules, i.e. </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>guard</span><span>›</span></span></span><span>.</span><span>

</span><span>  </span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> represents a proof obligation.</span><span>
  </span><span>Proof obligations in reasoning rules should be represented by it.</span><span>

</span><span>  </span><span class="antiquoted"><span>➧</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> by contrast</span><span>
  </span><span>represents proof obligations </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q›</span></span></span><span> that are ready to be solved by user (or by automatic tools).</span><span>
</span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
  </span><span>The difference between </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> is subtle:
</span><span>  In a reasoning process, many reasoning rules may be applied, which may generate many
</span><span>  </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span>.
</span><span>  The engine tries to solve </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> automatically but if it fails the search branch
</span><span>  would be stuck. Because the search has not been finished, it is bad to ask users' intervention
</span><span>  to solve the goal because the search branch may high-likely fail later.
</span><span>  It is </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>not ready</span><span>›</span></span></span><span> for user to solve </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> here, and suggestively </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> should be deferred to
</span><span>  an ideal moment for user solving obligations.
</span><span>  This is `ideal moment' is </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>. If any </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> exists in the antecedents
</span><span>  of the sequent, the engine contracts </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> into the latest </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>, e.g., from
</span><span>  \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾 P ⟹ A1 ⟹ 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 Q ⟹ 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 Q' ⟹ ⋯ ›</span></span></span><span> \]
</span><span>  it deduces
</span><span>  \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A1 ⟹ 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 Q ∧ P ⟹ 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 Q' ⟹ ⋯ ›</span></span></span><span> \]
</span><span>  In short, </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> collects obligations generated during a reasoning process,
</span><span>  and enables user to solve them at an idea moment.
</span><span>
</span><span>  A typical reasoning request (the initial reasoning state namely the argument of the reasoning
</span><span>  process) is of the following form,
</span><span> \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Problem ⟹ 𝗋Success ⟹ 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 True ⟹ Conclusion›</span></span></span><span> \]
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>True›</span></span></span><span> represents empty collection or none obligation.
</span><span>  If the reasoning succeeds, it returns sequent in form
</span><span> \[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 True ∧ P1 ∧ P2 ∧ ⋯ ⟹ Conclusion›</span></span></span><span> \]
</span><span>  where </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P1, P2, ⋯›</span></span></span><span> are obligations generated by reasoning </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Problem›</span></span></span><span>.
</span><span>  And then, user may solve the obligations manually or by automatic tools.
</span><span>
</span><span>  For antecedent </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>,
</span><span>  if there is another </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q'</span></span><span>›</span></span></span><span> in the remaining antecedents,
</span><span>  the reasoner also defer </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q›</span></span></span><span> to </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q'›</span></span></span><span>, just like </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> is a </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span>.
</span><span>
</span><span>  If no </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q'</span></span><span>›</span></span></span><span> exists in the remaining antecedents,
</span><span>  the reasoner of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> raises
</span><span>  an error aborting the whole reasoning, because the reasoning request is not configured correctly.
</span><span>
</span><span>  Semantically, </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> represents a proof obligation </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q›</span></span></span><span> intended to be addressed by
</span><span>  user. It can be deferred but the reasoner never attempts to solve </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span>›</span></span></span><span> practically.
</span><span>
</span><span>  Nonetheless, we still provide tool for reasoning obligations automatically, albeit they have
</span><span>  to be called separately with the reasoning engine. See </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹auto_obligation_solver›</span></span></span><span> and
</span><span>  </span><span class="antiquoted"><span class="operator"><span>▩</span></span><span class="raw_text"><span>‹safer_obligation_solver›</span></span></span><span> in </span><span class="antiquoted"><span class="operator"><span>🗏</span></span><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoners.ML.html"><span>‹library/reasoners.ML›</span></a></span><span>.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_I|thm"><span>Premise_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/classical.ML.html#HOL.intro|attribute"><span class="operator"><span>intro</span></span></a><span class="main"><span class="main"><span class="main"><span class="main"><span>!</span></span></span></span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_D|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_D|thm"><span>Premise_D</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>P</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_E|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_E|thm"><span>Premise_E</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/classical.ML.html#HOL.elim|attribute"><span class="operator"><span>elim</span></span></a><span class="main"><span class="main"><span class="main"><span class="main"><span>!</span></span></span></span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>C</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation of the reasoners</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_True|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_True|thm"><span>Premise_True</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 5000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 5000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>any_mode</span></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>TODO:
On pattern ‹Premise ?mode (?x = ?var_x)›, the instantiation in this rule can be aggresive.
Need some way to control it!
</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_refl|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Premise_refl|thm"><span>Premise_refl</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 2000 </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span>for</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a></a></a><span> </span><span class="var"><span class="var"><span class="var"><span>?mode</span></span></span></span><span> </span><span class="main"><span class="main"><span class="main"><span>(</span></span></span></span><span class="var"><span class="var"><span class="var"><span>?x</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span></a></span></a></span><span> </span><span class="var"><span class="var"><span class="var"><span>?x</span></span></span></span><span class="main"><span class="main"><span class="main"><span>)</span></span></span></span><span>›</span></span></span></span></span><span>
                                    </span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a></a></a><span> </span><span class="var"><span class="var"><span class="var"><span>?mode</span></span></span></span><span> </span><span class="main"><span class="main"><span class="main"><span>(</span></span></span></span><span class="var"><span class="var"><span class="var"><span>?x</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span></a></span></a></span><span> </span><span class="var"><span class="var"><span class="var"><span>?var_x</span></span></span></span><span class="main"><span class="main"><span class="main"><span>)</span></span></span></span><span>›</span></span></span></span></span><span>
                                    </span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a></a></a><span> </span><span class="var"><span class="var"><span class="var"><span>?mode</span></span></span></span><span> </span><span class="main"><span class="main"><span class="main"><span>(</span></span></span></span><span class="var"><span class="var"><span class="var"><span>?var_x</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span></a></span></a></span><span> </span><span class="var"><span class="var"><span class="var"><span>?x</span></span></span></span><span class="main"><span class="main"><span class="main"><span>)</span></span></span></span><span>›</span></span></span></span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_obligations|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_obligations|thm"><span>contract_obligations</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>Q</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="free"><span>Q</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>C</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/classical.ML.html#HOL.rule|method"><span class="operator"><span>rule</span></span></a><span> </span><span class="operator"><span>simp</span></span><span class="main"><span class="keyword3"><span>+</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_true|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_true|thm"><span>contract_premise_true</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_imp|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_imp|thm"><span>contract_premise_imp</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span class="free"><span>A</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_imp|fact"><span>atomize_imp</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_all|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.contract_premise_all|thm"><span>contract_premise_all</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>∀</span></a></span><span class="bound"><span>x</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>.</span></a></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_all|fact"><span>atomize_all</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>declare</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>[</span></span><span class="operator"><span>ML_debugger</span></span><span> </span><span class="main"><span class="main"><span>=</span></span></span><span> </span><span class="quasi_keyword"><span>true</span></span><span class="main"><span>]</span></span><span class="main"><span>]</span></span><span>

</span><span class="keyword1"><span class="command"><span>ML</span></span></span><span> </span><span class="quoted"><span>‹</span><span>
</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Useful_Thms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Named_Thms</span></span><span> </span><span class="main"><span>(</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>name</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.useful|attribute"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.useful|fact"><span>useful</span></span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>description</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"theorems to be inserted in the automatic proving, \
        \having the same effect of using the @{command using} command."</span></span><span>
</span><span class="main"><span>)</span></span><span>
</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>setup</span></span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>Useful_Thms.setup</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/PLPR_Syntax.ML.html"><span>‹</span><span>library/PLPR_Syntax.ML</span><span>›</span></a></span><span>
</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoners.ML.html"><span>"</span><span>library/reasoners.ML</span><span>"</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>Normal_Premise</span></a></span><span> 10 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="var"><span>?P</span></span><span>›</span></span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Proof_Obligation|const"><span>𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇</span></a></span><span> </span><span class="var"><span>?P</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>Phi_Reasoners.wrap</span></span><span> </span><span class="entity"><span>Phi_Reasoners.defer_obligation_tac</span></span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Reasoning Frame</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Antecedents </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span> conform a nested reasoning scope
</span><span>resembling a subroutine for specific reasoning tasks or problems.
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>… ⟹ 𝗋BEGIN ⟹ Nested ⟹ Reasoning ⟹ 𝗋END ⟹ …›</span></span></span><span> \]
</span><span>The scoped antecedents should be regarded as a </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>unit antecedent</span><span>›</span></span></span><span>
</span><span>invoking a nested φ-LPR reasoning process and returning </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>only</span><span>›</span></span></span><span> the first reached solution (
</span><span>just as the behaviour of φ-LPR engine).
</span><span>During backtracking, search branches before the unit will be backtracked but sub-optimal solutions
</span><span>of the unit are not backtracked.
</span><span>In addition, cut is confined among the search paths in the scope as a unit.
</span><span>Because of the cut and the reduced backtrack behavior, the performance is improved.
</span><span>
</span><span>Sometimes a cut is admissible (green) as an expected behavior among several rules and reasoners
</span><span>which constitute a loosely-gathered module for a specific problem.
</span><span>However the cut is still not safe to be used because an external rule using the reasoning module
</span><span>may demand the behavior of backtracking but the cut inside the module prevents
</span><span>backtracks in the external rule.
</span><span>In this case, the reasoning scope is helpful to wrap the loosely-gathered module to be confined
</span><span>by closing side effects like cuts.
</span><span>
</span><span>Specifically, any search path that reaches </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span> opens a new </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>frame</span><span>›</span></span></span><span> namely a space
</span><span>of search paths.
</span><span>The sub-searches continuing the path and before reaching
</span><span>the paired </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span> are in this frame.
</span><span>As φ-LPR works in BFS, a frame can contain another frame just if the search in the frame
</span><span>encounters another </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span>.
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>… ⟹ 𝗋BEGIN ⟹ A<span class="hidden">⇩</span><sub>1</sub> ⟹ 𝗋BEGIN ⟹ A<span class="hidden">⇩</span><sub>2</sub> ⟹ 𝗋END ⟹ A<span class="hidden">⇩</span><sub>3</sub> ⟹ 𝗋END ⟹ …›</span></span></span><span> \]
</span><span>Once any search path encounters a </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span>, the innermost frame is closed and the sequent of the
</span><span>search path is returned with dropping all other branches in the frame.
</span><span>The mechanism checks whether all </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span> are paired.
</span><span>
</span><span>Any global cut cuts all and only all search branches in the innermost frame to which the cut
</span><span>belongs. </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></a><span>›</span></span></span><span> is prohibited in the nested scope because we do not know how to process
</span><span>the remain antecedents after the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Success|const"><span>𝗋Success</span></a><span>›</span></span></span><span> and how to return them into the outer scope.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call|const"><span>𝗋Call</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗋CALL</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>3</span><span class="main"><span>]</span></span><span> 2</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Call</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>
  </span><span class="comment1"><span>― ‹</span><span>Call the antecedent </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> in a frame</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_I|thm"><span>𝗋BEGIN_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN_def|fact"><span>𝗋BEGIN_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_I|thm"><span>𝗋END_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END_def|fact"><span>𝗋END_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_I|thm"><span>𝗋Call_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call|const"><span>𝗋CALL</span></a></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_def|fact"><span>𝗋Call_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/nested.ML.html"><span>‹</span><span>library/nested.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;BEGIN|const"><span>𝗋BEGIN</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Nested_Reasoning.enter_scope</span></span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;END|const"><span>𝗋END</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Nested_Reasoning.exit_scope</span></span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call|const"><span>𝗋Call</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call|const"><span>𝗋Call</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Nested_Reasoning.call</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed|const"><span>𝗋Call_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Call_embed</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call|const"><span>𝗋Call</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed|const"><span>𝗋Call_embed</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_def|fact"><span>𝗋Call_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Call_embed_def|fact"><span>𝗋Call_embed_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Pruning</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>At a reasoning state </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span>, multiple search branches may be emitted parallel to
</span><span>find a solution of the antecedent.
</span><span>A branch may find the solution while other branches from </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span> still remain in the search history.
</span><span>Then the reasoning in DFS manner keeps to solve next antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B›</span></span></span><span> and we assume </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B›</span></span></span><span> fails.
</span><span>The reasoning then backtrack, and redo the search of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span> on remaining branches of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span>.
</span><span>It is not reasonable because the reasoning is redoing a solved problem on </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span>.
</span><span>To address this, a solution is to prune branches of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span> after </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span> succeeds.
</span><span>
</span><span>In this section we introduce </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>subgoal›</span></span></span><span> mechanism achieving the pruning.
</span><span>Each antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span> is tagged with a goal context </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span>, as </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹A <span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b> G››</span></span></span><span>.
</span><span>A reasoning rule may check that the goal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> has not been solved before doing any substantial
</span><span>computation, e.g.,
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>CHK_SUBGOAL G ⟹ Computation ⟹ (Ant <span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b> G)›</span></span></span><span> \]
</span><span>Antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>CHK_SUBGOAL G›</span></span></span><span> succeeds only when the goal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> is not marked solved, </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>or</span><span>›</span></span></span><span>, the current
</span><span>  search branch is the thread that marked </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> solved previously.
</span><span>When a rule succeeds, the rule may mark the goal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> solved to prune other branches that check </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span>.
</span><span>\[ </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Computation ⟹ SOLVE_SUBGOAL G ⟹ (Ant <span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b> G)›</span></span></span><span> \]
</span><span>If a goal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> has been marked solved, any other antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>SOLVE_SUBGOAL G›</span></span></span><span> marking </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> again, will
</span><span>fail, unless the current search branch is the thread that marked </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> solved previously.
</span><span>
</span><span>A subgoal is represented by an unspecified type which only has a syntactic effect in the reasoning.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_subgoal|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_subgoal|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.arity_type_subgoal|axiom"><span>typedecl</span></span></span></span></span></span><span> </span><span class="quoted"><span>"</span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></span><span>"</span></span><span>

</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.subgoal_context|const"><span>subgoal_context</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.action|type"><span>action</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span>GOAL_CTXT</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>"</span></span></span><span>  </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span>_</span><span>  </span><span class="keyword1"><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>2</span><span class="main"><span>,</span></span><span>1000</span><span class="main"><span>]</span></span><span> 2</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="keyword1"><span class="free"><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>G</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag|const"><span>@action</span></a></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal_context|const"><span>subgoal_context</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>G</span></span></span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL|const"><span>CHK_SUBGOAL</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span> </span><span class="comment1"><span>― ‹</span><span>Check whether the goal is solved</span><span>›</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>CHK_SUBGOAL</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL|const"><span>SOLVE_SUBGOAL</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>SOLVE_SUBGOAL</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Subgoals are hierarchical, having the unique top-most goal named </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹TOP_GOAL››</span></span></span><span>.
</span><span>New goal contexts are obtained by antecedent </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹SUBGOAL G ?G'››</span></span></span><span> which assigns a new subgoal
</span><span>under an unsolved </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> to output variable </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?G'›</span></span></span><span>.
</span><span>The reasoning raises an error if </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?G'›</span></span></span><span> is not a schematic variable.
</span><span>
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹SOLVE_SUBGOAL G››</span></span></span><span> marks the goal </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G›</span></span></span><span> and all its subgoals solved.
</span><span>The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>TOP_GOAL›</span></span></span><span> can never be solved.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>consts</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.TOP_GOAL|const"><span>TOP_GOAL</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL|const"><span>SUBGOAL</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.subgoal|type"><span>subgoal</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>SUBGOAL</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>ROOT</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>NEW_GOAL</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>"</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation of the Subgoal Reasoners</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SUBGOAL_I|thm"><span>SUBGOAL_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SUBGOAL|const"><span>SUBGOAL</span></a><span> </span><span class="free"><span>ROOT</span></span><span> </span><span class="free"><span>NEWGOAL</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SUBGOAL_def|fact"><span>SUBGOAL_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_I|thm"><span>CHK_SUBGOAL_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.CHK_SUBGOAL|const"><span>CHK_SUBGOAL</span></a><span> </span><span class="free"><span>X</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.CHK_SUBGOAL_def|fact"><span>CHK_SUBGOAL_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_I|thm"><span>SOLVE_SUBGOAL_I</span></span></span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL|const"><span>SOLVE_SUBGOAL</span></a><span> </span><span class="free"><span>X</span></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL_def|fact"><span>SOLVE_SUBGOAL_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/Subgoal_Env.ML.html"><span>‹</span><span>library/Subgoal_Env.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SUBGOAL|const"><span>SUBGOAL</span></a></span><span> 2000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SUBGOAL|const"><span>SUBGOAL</span></a><span> </span><span class="var"><span>?ROOT</span></span><span> </span><span class="var"><span>?NEWGOAL</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>Subgoal_Env.subgoal</span></span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.CHK_SUBGOAL|const"><span>CHK_SUBGOAL</span></a></span><span> 2000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.CHK_SUBGOAL|const"><span>CHK_SUBGOAL</span></a><span> </span><span class="var"><span>?GOAL</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>Subgoal_Env.chk_subgoal</span></span><span>›</span></span><span>
</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL|const"><span>SOLVE_SUBGOAL</span></a></span><span> 9900 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.SOLVE_SUBGOAL|const"><span>SOLVE_SUBGOAL</span></a><span> </span><span class="var"><span>?GOAL</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>Subgoal_Env.solve_subgoal</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 800 </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span>for</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><span>Try</span></a></a></a><span> </span><span class="var"><span class="var"><span class="var"><span>?S</span></span></span></span><span> </span><span class="var"><span class="var"><span class="var"><span>?P</span></span></span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span></a></span></a></span></a></span><span> </span><span class="var"><span class="var"><span class="var"><span>?G</span></span></span></span><span>›</span></span></span></span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="free"><span>P</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span></a></span><span> </span><span class="free"><span>G</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try|const"><span>Try</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span> </span><span class="free"><span>P</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.GOAL_CTXT|const"><span><span class="hidden">❙</span><b>@</b><span class="hidden">❙</span><b>G</b><span class="hidden">❙</span><b>O</b><span class="hidden">❙</span><b>A</b><span class="hidden">❙</span><b>L</b></span></a></span><span> </span><span class="free"><span>G</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Try_def|fact"><span>Try_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Branch</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A ||| B›</span></span></span><span> is an antecedent way to encode search branch.
</span><span>Compared with the ordinary approach using multiple submissive rules,
</span><span>short-cut is featured by using subgoal. It tries each antecedent from left to right until
</span><span>      the first success of solving an antecedent, and none of the remains are attempted.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch|const"><span>Branch</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>infixr</span></span></span><span> </span><span class="quoted"><span>"</span><span class="keyword1"><span>|||</span></span><span>"</span></span><span> 3</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Branch</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>C</span></span><span class="main"><span>.</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_embed|const"><span>Branch_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Branch_embed</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.disj|const"><span>∨</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.atomize_Branch|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.atomize_Branch|thm"><span>atomize_Branch</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch|const"><span>Branch</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>A</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.disj|const"><span>∨</span></a></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_def|fact"><span>Branch_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.or_def|fact"><span>or_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><span>atomize_eq</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_imp|fact"><span>atomize_imp</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_all|fact"><span>atomize_all</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch|const"><span>Branch</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>A</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_embed|const"><span>Branch_embed</span></a><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_embed_def|fact"><span>Branch_embed_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.atomize_Branch|fact"><span>atomize_Branch</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_L|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_L|thm"><span>Branch_L</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch|const"><span>|||</span></a></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_def|fact"><span>Branch_def</span></a><span>
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
  </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="entity_def" id="offset_35760..35761">A</span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span>›</span></span></span><span>
  </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>C</span></span><span class="main"><span>.</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
    </span><span class="keyword3"><span class="command"><span>fix</span></span></span><span> </span><span class="skolem"><span>C</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span>
    </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="entity_def" id="offset_35858..35860">A'</span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="skolem"><span>C</span></span><span>›</span></span></span><span>
    </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="skolem"><span>C</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#offset_35858..35860"><span>A'</span></a><span class="main"><span>[</span></span><span class="operator"><span>OF</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#offset_35760..35761"><span>A</span></a><span class="main"><span>]</span></span><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_R|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Branch_R|thm"><span>Branch_R</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch|const"><span>|||</span></a></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Action_Tag_def|fact"><span>Action_Tag_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_def|fact"><span>Branch_def</span></a><span>
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
  </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="entity_def" id="offset_36019..36020">B</span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span>
  </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="main"><span>⋀</span></span><span class="bound"><span>C</span></span><span class="main"><span>.</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="bound"><span>C</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
    </span><span class="keyword3"><span class="command"><span>fix</span></span></span><span> </span><span class="skolem"><span>C</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>"</span></span></span><span>
    </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="entity_def" id="offset_36117..36119">B'</span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="skolem"><span>C</span></span><span>›</span></span></span><span>
    </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="skolem"><span>C</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#offset_36117..36119"><span>B'</span></a><span class="main"><span>[</span></span><span class="operator"><span>OF</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#offset_36019..36020"><span>B</span></a><span class="main"><span>]</span></span><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>declare</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000 </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_L|fact"><span>Branch_L</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch_R|fact"><span>Branch_R</span></a><span> </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span>for</span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><span class="var"><span>?A</span></span><span> </span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Branch|const"><span>|||</span></a></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="var"><span>?B</span></span><span>›</span></span></span><span class="main"><span>]</span></span><span class="main"><span>]</span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Simplification \&amp; Rewrite</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>‹𝗌𝗂𝗆𝗉𝗅𝗂𝖿𝗒[mode] ?result : term››</span></span></span><span> is generic antecedent for simplifying </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>term›</span></span></span><span> in different
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>mode›</span></span></span><span>. The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>?result›</span></span></span><span> should be an output variable for the result of the simplification.
</span><span>
</span><span>  We implement a </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>default›</span></span></span><span> mode where the system simple-set is used to simplify
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>term›</span></span></span><span>. Users may configure their mode and their reasoner using different simple-set.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.mode|type"><span>mode</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span>"</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗌𝗂𝗆𝗉𝗅𝗂𝖿𝗒[</span></span><span>_</span><span class="keyword1"><span>]</span></span><span> </span><span>_</span><span> </span><span class="keyword1"><span>:</span></span><span class="keyword3"><span>/ </span></span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>10</span><span class="main"><span>,</span></span><span>1000</span><span class="main"><span>,</span></span><span>10</span><span class="main"><span>]</span></span><span> 9</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Simplify</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>setting</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>result</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>origin</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>result</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>origin</span></span></span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplificatin_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplificatin_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplificatin_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplificatin|const"><span>Do_Simplificatin</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Do_Simplificatin</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>result</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>origin</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>result</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>origin</span></span></span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><span class="operator"><span>cong</span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span>A'</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><span class="free"><span>s</span></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><span class="free"><span>s</span></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="free"><span>A'</span></span><span> </span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_D|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_D|thm"><span>Simplify_D</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify_def|fact"><span>Simplify_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Simplify_I|thm"><span>Simplify_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify_def|fact"><span>Simplify_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplification|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Simplification|thm"><span>Do_Simplification</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin|const"><span>Do_Simplificatin</span></a><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><span class="free"><span>s</span></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin_def|fact"><span>Do_Simplificatin_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify_def|fact"><span>Simplify_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><span>atomize_eq</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Simplification|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Simplification|thm"><span>End_Simplification</span></span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin|const"><span>Do_Simplificatin</span></a><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>A</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin_def|fact"><span>Do_Simplificatin_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Simplification&apos;|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Simplification&apos;|thm"><span>End_Simplification'</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin|const"><span>Do_Simplificatin</span></a><span> </span><span class="free"><span>A</span></span><span> </span><span class="free"><span>B</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplificatin_def|fact"><span>Do_Simplificatin_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Premise_def|fact"><span>Premise_def</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><span>atomize_eq</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/simplifier.ML.html"><span>‹</span><span>library/simplifier.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>hide_fact</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Simplification&apos;|fact"><span>End_Simplification'</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Simplification|fact"><span>End_Simplification</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Simplification|fact"><span>Do_Simplification</span></a><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Default Simplifier</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Default_Simplify|const"><span>Default_Simplify</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span>"</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗌𝗂𝗆𝗉𝗅𝗂𝖿𝗒</span></span><span> </span><span>_</span><span> </span><span class="keyword1"><span>:</span></span><span> </span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>1000</span><span class="main"><span>,</span></span><span>10</span><span class="main"><span>]</span></span><span> 9</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>Default_Simplify</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simplify|const"><span>Simplify</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.default|const"><span>default</span></a><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Default_Simplify|const"><span>Default_Simplify</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Default_Simplify|const"><span>Default_Simplify</span></a><span> </span><span class="var"><span>?X'</span></span><span> </span><span class="var"><span>?X</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Simplifier.simplifier</span></span><span> </span><span>NONE</span><span> </span><span>I</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simp_Premise|const"><span>Simp_Premise</span></a></span><span> 10 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Simp_Premise|const"><span>𝗌𝗂𝗆𝗉𝗋𝖾𝗆</span></a></span><span> </span><span class="var"><span>?P</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Simplifier.simplifier</span></span><span> </span><span>NONE</span><span> </span><span>I</span><span>›</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span> subsection ‹Exhaustive Divergence›

ML_file ‹library/exhaustive_divergen.ML›

definition ‹Begin_Exhaustive_Divergence ⟷ True›
definition ‹  End_Exhaustive_Divergence ⟷ True›
definition [iff]: ‹Stop_Divergence ⟷ True›

lemma Stop_Divergence_I: ‹Stop_Divergence› unfolding Stop_Divergence_def ..

lemma Begin_Exhaustive_Divergence_I: ‹Begin_Exhaustive_Divergence›
  unfolding Begin_Exhaustive_Divergence_def ..

lemma End_Exhaustive_Divergence_I: ‹End_Exhaustive_Divergence›
  unfolding End_Exhaustive_Divergence_def ..

φreasoner_ML Begin_Exhaustive_Divergence 1000 (‹Begin_Exhaustive_Divergence›)
  = ‹PLPR_Exhaustive_Divergence.begin Seq.of_list›

φreasoner_ML Stop_Divergence 1000 (‹Stop_Divergence›) =
  ‹apsnd (fn th =&gt; @{thm Stop_Divergence_I} RS th) #&gt; PLPR_Exhaustive_Divergence.stop›

φreasoner_ML End_Exhaustive_Divergence 1000 (‹End_Exhaustive_Divergence›)
  = ‹PLPR_Exhaustive_Divergence.exit›
</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Optimal Solution</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>φ-LPR is priority-driven DFS searching the first reached solution which may not be the optimal
</span><span>  one for certain measure. The section gives a way to find out the solution of the minimum cost
</span><span>  among a given set of candidates.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution|const"><span>Optimum_Solution</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Optimum_Solution</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution|const"><span>Begin_Optimum_Solution</span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution|const"><span>End_Optimum_Solution</span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Each individual invocation of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Optimum_Solution P›</span></span></span><span>
</span><span>invokes an individual instance of the optimal solution reasoning.
</span><span>The reasoning of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P›</span></span></span><span> is proceeded exhaustively meaning exploring all backtracks except local cuts.</span><span>
</span><span>›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Candidates</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The candidates are all search branches diverged from the antecedents marked by</span><span> </span><span>›</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span> definition 𝗋Choice :: ‹prop ⇒ prop› ("𝗋CHOICE _" [3] 2) where ‹𝗋Choice P ≡ P›

lemma 𝗋Choice_I: ‹ PROP P ⟹ PROP 𝗋Choice P› unfolding 𝗋Choice_def . </span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>For the antecedents marked by </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Choice›</span></span></span><span>, the mechanism traverses exhaustively all
</span><span>combinations of their (direct) solvers, but for other not marked antecedents, the strategy is
</span><span>not changed and is as greedy as the usual behavior --- returning the first-reached solution
</span><span>and discarding the others.
</span><span>
</span><span>As an example, in
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Begin_Optimum_Solution ⟹ 𝗋Choice A ⟹ B ⟹ 𝗋Choice C ⟹ End_Optimum_Solution ⟹ …›</span></span></span><span>,
</span><span>assuming both </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A,B,C›</span></span></span><span> have 2 solvers </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A<span class="hidden">⇩</span><sub>1</sub>,A<span class="hidden">⇩</span><sub>2</sub>,B<span class="hidden">⇩</span><sub>1</sub>,B<span class="hidden">⇩</span><sub>2</sub>,C<span class="hidden">⇩</span><sub>1</sub>,C<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> and assuming </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> have higher priority
</span><span>than </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> and can success, the mechanism traverses 4 combination of the solvers </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A<span class="hidden">⇩</span><sub>1</sub>,C<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span>,
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A<span class="hidden">⇩</span><sub>1</sub>,C<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A<span class="hidden">⇩</span><sub>2</sub>,C<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A<span class="hidden">⇩</span><sub>2</sub>,C<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span>, i.e., only exhaustively on </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Choice›</span></span></span><span>-marked antecedents but still
</span><span>greedy on others.
</span><span>
</span><span>Note, even marked by </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Choice›</span></span></span><span>, local cuts are still valid and cuts search branches.
</span><span>Global cut is disabled during the whole reasoning because it kills other search branches.
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Success›</span></span></span><span> is available and the mechanism ensures it is always the optimal one invokes the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>𝗋Success›</span></span></span><span>.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Cost</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The cost is measured by reports from the following antecedents inserted in the user rules.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost|const"><span>Incremental_Cost</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/Int.html#Int.int|type"><span>int</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Incremental_Cost</span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost|const"><span>Threshold_Cost</span></span></span><span>   </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/Int.html#Int.int|type"><span>int</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗍𝗁𝗋𝖾𝗌𝗁𝗈𝗅𝖽</span></span><span>"</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Threshold_Cost</span></span><span>   </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The final cost of a reasoning process is the sum of all the reported </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Incremental_Cost›</span></span></span><span> or
</span><span>  the maximum </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Threshold_Cost›</span></span></span><span>, the one which is larger.
</span><span>
</span><span>If the cost of two branches are the same, the first reached one is considered better.</span><span>
</span><span>›</span></span></span><span>



</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Solution_embed|const"><span>Optimum_Solution_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Optimum_Solution_embed</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution|const"><span>Optimum_Solution</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution_embed|const"><span>Optimum_Solution_embed</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution_embed_def|fact"><span>Optimum_Solution_embed_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution_def|fact"><span>Optimum_Solution_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Incremental_Cost_I|thm"><span>Incremental_Cost_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Incremental_Cost|const"><span>Incremental_Cost</span></a><span> </span><span class="free"><span>X</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Incremental_Cost_def|fact"><span>Incremental_Cost_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Threshold_Cost_I|thm"><span>Threshold_Cost_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Threshold_Cost|const"><span>Threshold_Cost</span></a><span> </span><span class="free"><span>X</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Threshold_Cost_def|fact"><span>Threshold_Cost_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_I|thm"><span>Begin_Optimum_Solution_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution|const"><span>Begin_Optimum_Solution</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_def|fact"><span>Begin_Optimum_Solution_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.End_Optimum_Solution_I|thm"><span>End_Optimum_Solution_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution|const"><span>End_Optimum_Solution</span></a><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution_def|fact"><span>End_Optimum_Solution_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Optimum_Solution|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_Optimum_Solution|thm"><span>Do_Optimum_Solution</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>X</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution|const"><span>End_Optimum_Solution</span></a><span>
</span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution|const"><span>Optimum_Solution</span></a><span> </span><span class="free"><span>X</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution_def|fact"><span>Optimum_Solution_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>
                                    
</span><span class="keyword1"><span class="command"><span>ML_file_debug</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/optimum_solution.ML.html"><span>‹</span><span>library/optimum_solution.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Incremental_Cost|const"><span>Incremental_Cost</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Incremental_Cost|const"><span>Incremental_Cost</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>HOLogic.dest_number</span></span><span> </span><span class="entity"><span>N</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sequent'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Incremental_Cost_I|fact"><span>Incremental_Cost_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Optimum_Solution.report_cost</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>n</span></span><span class="main"><span>,</span></span><span class="inner_numeral"><span>0</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Threshold_Cost|const"><span>Threshold_Cost</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Threshold_Cost|const"><span>Threshold_Cost</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>HOLogic.dest_number</span></span><span> </span><span class="entity"><span>N</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sequent'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Threshold_Cost_I|fact"><span>Threshold_Cost_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Optimum_Solution.report_cost</span></span><span> </span><span class="main"><span>(</span></span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span class="entity"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution|const"><span>Optimum_Solution</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><span>PROP</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Solution|const"><span>Optimum_Solution</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>
  </span><span> </span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_Optimum_Solution|fact"><span>Do_Optimum_Solution</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
</span><span>#&gt;</span><span> </span><span class="entity"><span>PLPR_Optimum_Solution.start</span></span><span>
</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution|const"><span>Begin_Optimum_Solution</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution|const"><span>Begin_Optimum_Solution</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>
  </span><span> </span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Begin_Optimum_Solution_I|fact"><span>Begin_Optimum_Solution_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
</span><span>#&gt;</span><span> </span><span class="entity"><span>PLPR_Optimum_Solution.start</span></span><span>
</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution|const"><span>End_Optimum_Solution</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution|const"><span>End_Optimum_Solution</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>
  </span><span> </span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.End_Optimum_Solution_I|fact"><span>End_Optimum_Solution_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
</span><span>#&gt;</span><span> </span><span class="entity"><span>PLPR_Optimum_Solution.finish</span></span><span>
</span><span>›</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>φreasoner_ML 𝗋Choice 1000 (‹PROP 𝗋Choice _›) = ‹fn (ctxt,sequent) =&gt;
  PLPR_Optimum_Solution.choices (ctxt, @{thm 𝗋Choice_I} RS sequent)› </span><span>*</span><span>)</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Derivations</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among|const"><span>Optimum_Among</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Optimum_Among</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Candidates</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Candidates</span></span></span></span><span>›</span></span></span><span>
  </span><span class="comment1"><span>― ‹</span><span>We leave it as a syntax merely</span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Optimum_Among_embed|const"><span>Optimum_Among_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Optimum_Among_embed</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Among|const"><span>Optimum_Among</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Among_embed|const"><span>Optimum_Among_embed</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Among_embed_def|fact"><span>Optimum_Among_embed_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Optimum_Among_def|fact"><span>Optimum_Among_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Environment Variables</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var|const"><span>Push_Envir_Var</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'name</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Push_Envir_Var</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Name</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Val</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var|const"><span>Pop_Envir_Var</span></span></span><span>  </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'name</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Pop_Envir_Var</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Name</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var|const"><span>Get_Envir_Var</span></span></span><span>  </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'name</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Get_Envir_Var</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Name</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Return</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;|const"><span>Get_Envir_Var'</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'name</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="tfree"><span>'a</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>Get_Envir_Var'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Name</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Default</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>Return</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/envir_var.ML.html"><span>‹</span><span>library/envir_var.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Push_Envir_Var_I|thm"><span>Push_Envir_Var_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Push_Envir_Var|const"><span>Push_Envir_Var</span></a><span> </span><span class="free"><span>N</span></span><span> </span><span class="free"><span>V</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Push_Envir_Var_def|fact"><span>Push_Envir_Var_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Pop_Envir_Var_I|thm"><span>Pop_Envir_Var_I</span></span></span><span class="main"><span>:</span></span><span>  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Pop_Envir_Var|const"><span>Pop_Envir_Var</span></a><span> </span><span class="free"><span>N</span></span><span>›</span></span></span><span>    </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Pop_Envir_Var_def|fact"><span>Pop_Envir_Var_def</span></a><span>  </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var_I|thm"><span>Get_Envir_Var_I</span></span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var|const"><span>Get_Envir_Var</span></a><span>  </span><span class="free"><span>N</span></span><span> </span><span class="free"><span>V</span></span><span>›</span></span></span><span>   </span><span class="keyword2"><span class="keyword"><span>for</span></span></span><span> </span><span class="free"><span>V</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'v</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var_def|fact"><span>Get_Envir_Var_def</span></a><span>  </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_I|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_I|thm"><span>Get_Envir_Var'_I</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;|const"><span>Get_Envir_Var'</span></a><span> </span><span class="free"><span>N</span></span><span> </span><span class="free"><span>D</span></span><span> </span><span class="free"><span>V</span></span><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>for</span></span></span><span> </span><span class="free"><span>V</span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'v</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span>›</span></span></span><span> </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_def|fact"><span>Get_Envir_Var'_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Push_Envir_Var|const"><span>Push_Envir_Var</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Push_Envir_Var|const"><span>Push_Envir_Var</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>maxidx_of_term</span><span> </span><span class="entity"><span>V</span></span><span> </span><span>&lt;&gt;</span><span> </span><span class="inner_numeral"><span>~1</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>warning</span><span> </span><span class="inner_quoted"><span>"PLPR Envir Var: The value to be assigned has schematic variables \
                           \which will not be retained!"</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.push</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.name_of</span></span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>V</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span>
            </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Push_Envir_Var_I|fact"><span>Push_Envir_Var_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
      </span><span>Seq.empty</span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Pop_Envir_Var|const"><span>Pop_Envir_Var</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Pop_Envir_Var|const"><span>Pop_Envir_Var</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.pop</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.name_of</span></span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Pop_Envir_Var_I|fact"><span>Pop_Envir_Var_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
      </span><span>Seq.empty</span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var|const"><span>Get_Envir_Var</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var|const"><span>Get_Envir_Var</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.maxidx_of</span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span>+</span><span> </span><span class="inner_numeral"><span>1</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>PLPR_Env.get</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.name_of</span></span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>Phi_Reasoner.error</span></span><span>
                      </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"No enviromental variable "</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>PLPR_Env.name_of</span></span><span> </span><span class="entity"><span>N</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>" is set"</span></span><span class="main"><span>)</span></span><span>
         </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>V'</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>V</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.incr_indexes_cterm</span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>V'</span></span><span class="main"><span>)</span></span><span>
             </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var_I|fact"><span>Get_Envir_Var_I</span></a><span class="antiquote"><span>}</span></span></span></span><span>
                        </span><span>|&gt;</span><span> </span><span>Thm.incr_indexes</span><span> </span><span class="entity"><span>idx</span></span><span>
                        </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.make</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"'v"</span></span><span class="main"><span>,</span></span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of_cterm</span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span>
                                             </span><span>Vars.make</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"V"</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>Thm.typ_of_cterm</span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
                         </span><span class="main"><span>)</span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
                    </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;|const"><span>Get_Envir_Var'</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;|const"><span>Get_Envir_Var'</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>N</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>D</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.maxidx_of</span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span>+</span><span> </span><span class="inner_numeral"><span>1</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>V</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>PLPR_Env.get</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Env.name_of</span></span><span> </span><span class="entity"><span>N</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
                                   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>V</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>V</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>D</span></span><span class="main"><span>)</span></span><span>
                </span><span>|&gt;</span><span> </span><span>Thm.incr_indexes_cterm</span><span> </span><span class="entity"><span>idx</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Get_Envir_Var&apos;_I|fact"><span>Get_Envir_Var'_I</span></a><span class="antiquote"><span>}</span></span></span></span><span>
                  </span><span>|&gt;</span><span> </span><span>Thm.incr_indexes</span><span> </span><span class="entity"><span>idx</span></span><span>
                  </span><span>|&gt;</span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.make</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"'v"</span></span><span class="main"><span>,</span></span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of_cterm</span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span>
                                       </span><span>Vars.make</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"V"</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>Thm.typ_of_cterm</span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>V</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
                   </span><span class="main"><span>)</span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
      </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="main"><span>)</span></span><span>›</span></span><span>


</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Recursion Guard</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋Recursion_Guard</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>prop</span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span class="quoted"><span>"</span><span class="keyword1"><span>𝗋RECURSION'_GUARD'(</span></span><span>_</span><span class="keyword1"><span>')</span></span><span class="keyword3"><span>/ </span></span><span>_</span><span>"</span></span><span> </span><span class="main"><span>[</span></span><span>2</span><span class="main"><span>,</span></span><span>2</span><span class="main"><span>]</span></span><span> 2</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/clasimp.ML.html#HOL.iff|attribute"><span class="operator"><span>iff</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="keyword1"><span class="free"><span>𝗋RECURSION_GUARD(</span></span></span><span class="free"><span class="bound"><span class="entity"><span>X</span></span></span></span><span class="main"><span class="free"><span>)</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋RECURSION_GUARD(</span></a></span><span class="free"><span>X</span></span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>)</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span> annotates the reasoning of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">prop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>P</span></span><span>›</span></span></span><span> is about goal </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>X</span></span><span>›</span></span></span><span>.
</span><span>It remembers </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>X</span></span><span>›</span></span></span><span> and once in the following reasoning the same goal </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>X</span></span><span>›</span></span></span><span> occurs again,
</span><span>it aborts the search branch because an infinite recursion happens.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed|const"><span>𝗋Recursion_Guard_embed</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Recursion_Guard_embed</span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>P</span></span></span></span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_atomize_rules|attribute"><span class="operator"><span>iso_atomize_rules</span></span></a><span class="main"><span>,</span></span><span> </span><span class="operator"><span>symmetric</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/iso_atomize.ML.html#Phi_Logic_Programming_Reasoner.iso_rulify_rules|attribute"><span class="operator"><span>iso_rulify_rules</span></span></a><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋Recursion_Guard</span></a><span> </span><span class="free"><span>X</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed|const"><span>𝗋Recursion_Guard_embed</span></a><span> </span><span class="free"><span>X</span></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_embed_def|fact"><span>𝗋Recursion_Guard_embed_def</span></a><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_def|fact"><span>𝗋Recursion_Guard_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsubsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Implementation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue_def|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue_def|thm"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue|const"><span>𝗋Recursion_Residue</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="tfree"><span>'a</span></span><span class="main"><span>::</span></span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>𝗋Recursion_Residue</span></span><span> </span><span class="main"><span class="bound"><span class="entity"><span>_</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_\&lt;r&gt;Recursion_Guard|fact"><span class="entity_def" id="Phi_Logic_Programming_Reasoner.Do_\&lt;r&gt;Recursion_Guard|thm"><span>Do_𝗋Recursion_Guard</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue|const"><span>𝗋Recursion_Residue</span></a><span> </span><span class="free"><span>X</span></span><span>
</span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋RECURSION_GUARD(</span></a></span><span class="free"><span>X</span></span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>)</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard_def|fact"><span>𝗋Recursion_Guard_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>[</span></span><a class="entity_ref" href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/reasoner.ML.html#Phi_Logic_Programming_Reasoner.\&lt;phi&gt;reason|attribute"><span class="operator"><span>φreason</span></span></a><span> 1000</span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue|const"><span>𝗋Recursion_Residue</span></a><span> </span><span class="free"><span>X</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Residue_def|fact"><span>𝗋Recursion_Residue_def</span></a><span> </span><span class="keyword1"><span class="command"><span>..</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>ML_file</span></span></span><span> </span><span class="quoted"><a href="USER_HOME/Current/phi-system/Phi_Logic_Programming_Reasoner/library/recursion_guard.ML.html"><span>‹</span><span>library/recursion_guard.ML</span><span>›</span></a></span><span>

</span><span class="keyword1"><span class="command"><span>φreasoner_ML</span></span></span><span> </span><span class="quoted"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋Recursion_Guard</span></a></span><span> 1000 </span><span class="main"><span>(</span></span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>𝗋RECURSION_GUARD(</span></a></span><span class="var"><span>?X</span></span><span class="main"><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.\&lt;r&gt;Recursion_Guard|const"><span>)</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="var"><span>?P</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span class="entity"><span>PLPR_Recursion_Guard.reason</span></span><span>›</span></span><span>

</span><span class="keyword1"><span class="command"><span>hide_fact</span></span></span><span> </span><a class="entity_ref" href="Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Do_\&lt;r&gt;Recursion_Guard|fact"><span>Do_𝗋Recursion_Guard</span></a><span>

</span><span class="comment1"><span>(</span><span>*</span><span>
subsection ‹Obtain› ― ‹A restricted version of generalized elimination for existential only›
  ― ‹Maybe Useless, considering to discard!›

definition Obtain :: ‹'a ⇒ ('a ⇒ bool) ⇒ bool› where ‹Obtain x P ⟷ P x›
definition ‹DO_OBTAIN ≡ Trueprop True›

lemma DO_OBTAIN_I: ‹PROP DO_OBTAIN› unfolding DO_OBTAIN_def ..
lemma Obtain_Framework:
  ‹PROP Sequent ⟹ PROP GE ⟹ PROP DO_OBTAIN ⟹ PROP Sequent &amp;&amp;&amp; PROP GE›
  using conjunctionI .

lemma Obtain_I:
  ‹P x ⟹ Obtain x P›
  unfolding Obtain_def .

φreasoner_ML Obtain 1200 (‹Obtain ?x ?P›) = ‹
fn (ctxt, sequent) =&gt;
  let
    val obtain_goal = Thm.major_prem_of sequent
    fun obtain_goal_vars L (Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Obtain›, _) $ V $ P) = obtain_goal_vars (V::L) P
      | obtain_goal_vars L (<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ P) = obtain_goal_vars L P
      | obtain_goal_vars L (Abs (_,_,P)) = obtain_goal_vars L P
      | obtain_goal_vars L _ = L
    fun to_ex_goal (Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Obtain›, Type ("fun", [_, ty])) $ _ $ P)
          = Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Ex›, ty) $ to_ex_goal P
      | to_ex_goal (<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ P) = <span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ to_ex_goal P
      | to_ex_goal (Abs (N,Ty,P)) = Abs (N,Ty, to_ex_goal P)
      | to_ex_goal P = P
    val goal = Thm.trivial (Thm.cterm_of ctxt (to_ex_goal obtain_goal))
    val L = obtain_goal_vars [] obtain_goal
   in
    if forall is_Var L
    then Seq.single (ctxt, goal RS (sequent COMP @{thm Obtain_Framework}))
    else error("asdwh78")
  end
›

φreasoner_ML DO_OBTAIN 1200 (‹PROP DO_OBTAIN›) = ‹
fn (ctxt, sequent') =&gt; Seq.make (fn _ =&gt;
  let
    val sequent'' = @{thm DO_OBTAIN_I} RS sequent'
    val (sequent, GE') = Conjunction.elim sequent''
    val obtain_goal = Thm.major_prem_of sequent
    fun obtain_goal_vars L (Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Obtain›, _) $ V $ P) = obtain_goal_vars (V::L) P
      | obtain_goal_vars L (<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ P) = obtain_goal_vars L P
      | obtain_goal_vars L (Abs (_,_,P)) = obtain_goal_vars L P
      | obtain_goal_vars L _ = L
    fun get_goal (Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Obtain›, _) $ _ $ P) = get_goal P
      | get_goal (Abs (_,_,P)) = get_goal P
      | get_goal (<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ P) = get_goal P
      | get_goal P = P
    val L = obtain_goal_vars [] obtain_goal
    val N = length L
    val GE = Tactical.REPEAT_DETERM_N N
                (Thm.biresolution NONE false [(true, @{thm exE})] 1) GE' |&gt; Seq.hd
    val (var_names, ctxt') = Proof_Context.add_fixes
          (map (fn tm =&gt; (Binding.name (Term.term_name tm), SOME (fastype_of tm), NoSyn)) L) ctxt
    val vars = map Free (var_names ~~ map Term.fastype_of L)
    val vars_c = map (Thm.cterm_of ctxt') vars
    val assm =
        Term.subst_bounds (vars, get_goal obtain_goal)
          |&gt; Thm.cterm_of ctxt'
    fun export_assm thm = thm
          |&gt; Thm.implies_intr assm
          |&gt; Drule.forall_intr_list vars_c
          |&gt; (fn th =&gt; th COMP GE)
    val ([assm_thm], ctxt'') = Assumption.add_assms (fn _ =&gt; fn _ =&gt; (export_assm, I)) [assm] ctxt'
    val sequent1 = Tactical.REPEAT_DETERM_N N
            (Thm.biresolution NONE false [(true, @{thm Obtain_I})] 1) sequent |&gt; Seq.hd
   in SOME ((ctxt'', assm_thm RS sequent1), Seq.empty)
  end
)›

</span><span>*</span><span>)</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span> subsection ‹Generalized Elimination›

definition "φGeneralized_Elimination x = x"

definition ‹DO_GENERALIZED_ELIMINATION ≡ Trueprop True›

lemma DO_GENERALIZED_ELIMINATION_I:
  ‹PROP DO_GENERALIZED_ELIMINATION›
  unfolding DO_GENERALIZED_ELIMINATION_def ..

lemma Generalized_Elimination_Framework:
  ‹ TERM P
⟹ TERM P ― ‹Unifies prop in Sequent and that in GE here›
⟹ PROP Sequent
⟹ PROP GE
⟹ PROP DO_GENERALIZED_ELIMINATION
⟹ PROP GE &amp;&amp;&amp; PROP Sequent›
  using Pure.conjunctionI .

ML_file ‹library/elimination.ML›

</span><span>*</span><span>)</span></span><span>


</span><span class="comment1"><span>(</span><span>*</span><span>
subsection ‹Misc›
 subsubsection ‹Collect Schematic \&amp; Free \&amp; other terms› ― ‹Not Stable!›

paragraph ‹Schematic›

definition ‹Collect_Schematic (typ::'a itself) sch Term ≡ Trueprop True›

text ‹It collects all schematic variables matching type <span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span>‹'a› in <span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span>‹Term›.
  The return is in form <span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span>‹Collect_Schematic TYPE('a) (v1, v2, v3) Term›.
  The matching of <span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span>‹'a› is in the usual way, where only schematic variables but no free variables
    are considered as variables that can match something.›

lemma Collect_Schematic_I: ‹PROP Collect_Schematic TY sch Term›
  unfolding Collect_Schematic_def ..

φreasoner_ML Collect_Schematic 1200 (‹PROP Collect_Schematic TYPE(?'a) ?sch ?Term›) = ‹
  fn (ctxt, sequent) =&gt;
    let
      val (Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Collect_Schematic›, _)
            $ Const (<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Pure.type›, Type(<span class="hidden">\&lt;^</span><span class="control">type_name</span><span class="hidden">&gt;</span>‹itself›, [T])))
            $ _
            $ Term
        = Thm.major_prem_of sequent
      val vs = fold_aterms (fn (v as Var (_, T')) =&gt; (fn L =&gt;
                                  if Type.could_match (T,T') then insert (op =) v L else L)
                             | _ =&gt; I) Term []
      val vs' = Thm.cterm_of ctxt (HOLogic.mk_tuple vs)
      val idx = Thm.maxidx_of_cterm vs' + 1
      val rule = Drule.infer_instantiate ctxt [(("sch",idx),vs')]
                    (Thm.incr_indexes idx @{thm Collect_Schematic_I})
    in Seq.single (ctxt, rule RS sequent)
    end
›
</span><span>*</span><span>)</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>Others, to be done!</span><span>*</span><span>)</span></span><span>


</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span></pre>
</body>

</html>