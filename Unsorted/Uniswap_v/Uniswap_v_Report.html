<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Uniswap_v_Report</title>
</head>


<body>
<div class="head">
<h1>Theory Uniswap_v_Report</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><a href="Uniswap_v_Report.html"><span>Uniswap_v_Report</span></a><span>
  </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="Uniswap_v_Report_helpers.html"><span>Uniswap_v_Report_helpers</span></a><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Introduction</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>The formalization given in this verification project is based on the Uniswap v3 whitepaper.</span><span>

</span><span>The contract system contains 3 major modules,</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>Swapping for exchanging tokens</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>Burn \&amp; Mint for providing and withdrawing liquidity</span><span>
</span><span class="antiquoted"><span>▪</span></span><span> </span><span>Observation for recording historical changes of the price.</span><span>

</span><span>To the date of the document, only the first module is specified and partially verified.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Specifying the swap operation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>The key concept of the swapping module is the correspondence between reserves of the two tokens,
</span><span>  the price, and the liquidity.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Specifying relationship between reserves, price, and liquidity</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>
</span><span>A key novelty of Uniswap v3 is </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>virtual liquidity</span><span>›</span></span></span><span>. Liquidity providers can limit their liquidity
</span><span>in a price interval so the amount of liquidity can be different at different price, making it a real
</span><span>function of price.
</span><span>
</span><span>To implement this, Uniswap discretizes the real function by splitting the price domain into many
</span><span>intervals named </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>ticks</span><span>›</span></span></span><span>, which are the minimal resolution unit of the price intervals of liquidity,
</span><span>so liquidity is constant in every tick.
</span><span>
</span><span>We formalize the conversion between prices and (lower bound of) ticks by </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.price_of|const"><span>price_of</span></a><span>›</span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.tick_of_price|const"><span>tick_of_price</span></a><span>›</span></span><span>,
</span><span>and lemmas </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.price_of_tick|fact"><span>price_of_tick</span></a><span class="antiquote"><span>}</span></span></span><span> </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.tick_of_price|fact"><span>tick_of_price</span></a><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>When the liquidity is constant in a price interval, the relation between the reserves and the price
</span><span>can be given, as the formula (6.16) and (6.13) in the whitepaper.
</span><span>
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Δx = Δ(1 / sqrt(P)) * L      Δy = Δ(sqrt(P)) * L›</span></span></span><span>
</span><span>
</span><span>We formalize this by </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>1</sub></span></span><span>›</span></span></span><span> which gives the change of
</span><span>the reserves of the token0 and the token1 respectively when the price moves from </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>p<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span> to </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>p<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span>,
</span><span>and when the liquidity between the prices is constant </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>L<span class="hidden">⇩</span><sub>0</sub>›</span></span></span><span>.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Uniswap_v_Report.reserve_change_in_a_step__definition|fact"><span class="entity_def" id="Uniswap_v_Report.reserve_change_in_a_step__definition|thm"><span>reserve_change_in_a_step__definition</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>1</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>L<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Fields.html#Fields.inverse_class.inverse_divide|const"><span>/</span></a></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.minus_class.minus|const"><span>-</span></a></span><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Fields.html#Fields.inverse_class.inverse_divide|const"><span>/</span></a></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>1</sub></span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>0</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.times_class.times|const"><span>*</span></a></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>p<span class="hidden">⇩</span><sub>1</sub></span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.minus_class.minus|const"><span>-</span></a></span><span> </span><span class="free"><span>p<span class="hidden">⇩</span><sub>0</sub></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step_def|fact"><span>reserve_change_in_a_step_def</span></a><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>As the liquidity between two arbitrary prices is not necessarily a constant but a function of
</span><span>the price, the reserve change between the two prices is the integral over the prices, namely,
</span><span>by splitting the price interval into several partitions in every of which the liquidity is constant,
</span><span>the sum of the evaluation of the every partition.
</span><span>
</span><span>We formalize this by </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval|const"><span>Const_Interval</span></a><span>›</span></span><span>, </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_partition|const"><span>Is_partition</span></a><span>›</span></span><span>, and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral|const"><span>partition_intergral</span></a><span>›</span></span><span>.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Uniswap_v_Report.Const_Interval__definition|fact"><span class="entity_def" id="Uniswap_v_Report.Const_Interval__definition|thm"><span>Const_Interval__definition</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval|const"><span>Const_Interval</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less_eq|const"><span>≤</span></a></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="main"><span>(</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>∀</span></a></span><span class="bound"><span>k</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.All|const"><span>.</span></a></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less_eq|const"><span>≤</span></a></span><span> </span><span class="bound"><span>k</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="bound"><span>k</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="bound"><span>k</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval_def|fact"><span>Const_Interval_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/HOL/Tools/SMT/smt_systems.ML.html#SMT.smt|method"><span class="operator"><span>smt</span></span></a><span> </span><span class="main"><span class="main"><span>(</span></span></span><span>verit</span><span class="main"><span class="main"><span>,</span></span></span><span> best</span><span class="main"><span class="main"><span>)</span></span></span><span class="main"><span>)</span></span><span> 

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="main"><span>::</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.price|type"><span>price</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.liquidity|type"><span>liquidity</span></a><span>›</span></span></span><span> is the function from prices to their liquidity.
</span><span>Predicate </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval|const"><span>Const_Interval</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>u</span></span><span>›</span></span></span><span> specifies </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>[l,u)›</span></span></span><span> is a price interval where the liquidity
</span><span>on the prices is constant.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Uniswap_v_Report.Is_partition__definition|fact"><span class="entity_def" id="Uniswap_v_Report.Is_partition__definition(2)|thm"><span class="entity_def" id="Uniswap_v_Report.Is_partition__definition(1)|thm"><span>Is_partition__definition</span></span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_partition|const"><span>Is_partition</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/List.html#List.list.Nil|const"><span>[]</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval|const"><span>Const_Interval</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>u</span></span><span>›</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_partition|const"><span>Is_partition</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="free"><span>h</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.plus_class.plus|const"><span>+</span></a></span><span> </span><span class="free"><span>r</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.iff|const"><span>⟷</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Const_Interval|const"><span>Const_Interval</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>l</span></span><span> </span><span class="free"><span>h</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_partition|const"><span>Is_partition</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>h</span></span><span> </span><span class="free"><span>u</span></span><span> </span><span class="free"><span>r</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span class="main"><span class="keyword3"><span>+</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>We use an order list (a chain) to represent a partition, e.g. </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="main"><span>[</span></span><span class="free"><span>x<span class="hidden">⇩</span><sub>0</sub></span></span><span class="main"><span>,</span></span><span class="free"><span>x<span class="hidden">⇩</span><sub>1</sub></span></span><span class="main"><span>,</span></span><span class="free"><span>x<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main"><span>]</span></span><span>›</span></span></span><span> for </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>[l,x<span class="hidden">⇩</span><sub>0</sub>), [x<span class="hidden">⇩</span><sub>0</sub>,x<span class="hidden">⇩</span><sub>1</sub>), [x<span class="hidden">⇩</span><sub>1</sub>,x<span class="hidden">⇩</span><sub>2</sub>), [x<span class="hidden">⇩</span><sub>2</sub>,u)›</span></span></span><span>.
</span><span>Predicate </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Is_partition f l u ps›</span></span></span><span> asserts if </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>ps›</span></span></span><span> is a valid partition where every interval has constant liquidity.
</span><span>
</span><span>Then, we can add up the evaluation of every partition to get the integral, by a recursion function as the following.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="Uniswap_v_Report.partition_intergral__definition|fact"><span class="entity_def" id="Uniswap_v_Report.partition_intergral__definition(2)|thm"><span class="entity_def" id="Uniswap_v_Report.partition_intergral__definition(1)|thm"><span>partition_intergral__definition</span></span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral|const"><span>partition_intergral</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>low</span></span><span> </span><span class="free"><span>up</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/List.html#List.list.Nil|const"><span>[]</span></a></span><span>
      </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>low</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>low</span></span><span> </span><span class="free"><span>up</span></span><span>›</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral|const"><span>partition_intergral</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>low</span></span><span> </span><span class="free"><span>up</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="free"><span>h</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.plus_class.plus|const"><span>+</span></a></span><span> </span><span class="free"><span>r</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>low</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>low</span></span><span> </span><span class="free"><span>h</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.plus_class.plus|const"><span>+</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral|const"><span>partition_intergral</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="free"><span>L<span class="hidden">⇩</span><sub>p</sub></span></span><span> </span><span class="free"><span>h</span></span><span> </span><span class="free"><span>up</span></span><span> </span><span class="free"><span>r</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span class="main"><span class="keyword3"><span>+</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Finally, we can specify the relationship between reserves, price, and liquidity,
</span><span>  which is the integral following any valid partition.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span>
</span><span class="quoted"><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change&apos;|const"><span>reserve_change'</span></a><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>lower</span></span><span> </span><span class="free"><span>upper</span></span><span>
    </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral|const"><span>partition_intergral</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_in_a_step|const"><span>reserve_change_in_a_step</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>L</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Fun.html#Fun.comp|const"><span>∘</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.tick_of_price|const"><span>tick_of_price</span></a><span class="main"><span>)</span></span><span> </span><span class="free"><span>lower</span></span><span> </span><span class="free"><span>upper</span></span><span>
                          </span><span class="main"><span>(</span></span><span class="keyword1"><span>SOME</span></span><span> </span><span class="bound"><span>ps</span></span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_partition|const"><span>Is_partition</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>L</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Fun.html#Fun.comp|const"><span>∘</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.tick_of_price|const"><span>tick_of_price</span></a><span class="main"><span>)</span></span><span> </span><span class="free"><span>lower</span></span><span> </span><span class="free"><span>upper</span></span><span> </span><span class="bound"><span>ps</span></span><span class="main"><span>)</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/HOL/Tools/Metis/metis_tactic.ML.html#Metis.metis|method"><span class="operator"><span>metis</span></span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/Hilbert_Choice.html#Hilbert_Choice.Eps_cong|fact"><span>Eps_cong</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.Is_key_partition_implies_Is_partition|fact"><span>Is_key_partition_implies_Is_partition</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change&apos;_def|fact"><span>reserve_change'_def</span></a><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change_irrelavent_with_partition|fact"><span>reserve_change_irrelavent_with_partition</span></a><span> </span><a class="entity_ref" href="../../HOL/HOL/Hilbert_Choice.html#Hilbert_Choice.someI_ex|fact"><span>someI_ex</span></a><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>L</span></span><span> </span><span class="main"><span>::</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.tick|type"><span>tick</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.liquidity|type"><span>liquidity</span></a><span>›</span></span></span><span> is the function from ticks to their liquidity.
</span><span>There is </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>L ∘ tick_of_price ≡ L<span class="hidden">⇩</span><sub>p</sub>›</span></span></span><span>.
</span><span>By lemma </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.partition_intergral_irrelavent_with_parition|fact"><span>partition_intergral_irrelavent_with_parition</span></a><span class="antiquote"><span>}</span></span></span><span>, the result of the integral is irrelavent
</span><span>with specific partitions.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Now we can specify the swap operation of Uniswap.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Specifying swap operation</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><a class="entity_ref" href="Uniswap_Pool.html#Uniswap_Pool.Pool|locale"><span>Pool</span></a><span class="main"><span>)</span></span><span>
 </span><span class="quoted"><span class="quoted"><span>‹</span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Phi_Logic_Programming_Reasoner.Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.zero_class.zero|const"><span>0</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.not_equal|const"><span>≠</span></a></span><span> </span><span class="free"><span>amount_specified</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.zero_class.zero|const"><span>0</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><span>⟹</span></span><span>
  </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Phi_Logic_Programming_Reasoner.Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="free"><span>unlocked</span></span><span> </span><span class="main"><span>⟹</span></span><span>
  </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Phi_Logic_Programming_Reasoner.Phi_Logic_Programming_Reasoner.html#Phi_Logic_Programming_Reasoner.Normal_Premise|const"><span>𝗉𝗋𝖾𝗆𝗂𝗌𝖾</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.MIN_PRICE|const"><span>MIN_PRICE</span></a><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Tick_Math.html#Uniswap_Tick_Math.MAX_PRICE|const"><span>MAX_PRICE</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span>

  </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.\&lt;phi&gt;Procedure_no_exception|const"><span>𝗉𝗋𝗈𝖼</span></a></span><span> </span><span>swap</span><span> </span><span class="main"><span>(</span></span><span class="free"><span>𝖺𝗋𝗀3</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;V_pair|const"><span><span class="hidden">❙</span><b>,</b></span></a></span><span> </span><span class="free"><span>𝖺𝗋𝗀2</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;V_pair|const"><span><span class="hidden">❙</span><b>,</b></span></a></span><span> </span><span class="free"><span>𝖺𝗋𝗀1</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.\&lt;phi&gt;Procedure_no_exception|const"><span>⦃</span></a></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>price</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>i</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>unlocked</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>Lg</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>L</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>growth</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>δ</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>fee_protocol</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>protocal_fees</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span>Uniswap_Pool</span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.COMMA|const"><span>❟</span></a></span><span>
     </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>𝗏𝖺𝗅[</span></a></span><span class="free"><span>𝖺𝗋𝗀1</span></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>]</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics/PhiSem_Generic_Boolean.html#PhiSem_Generic_Boolean.\&lt;phi&gt;Bool|const"><span>𝔹</span></a></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.COMMA|const"><span>❟</span></a></span><span> </span><span class="free"><span>amount_specified</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>𝗏𝖺𝗅[</span></a></span><span class="free"><span>𝖺𝗋𝗀2</span></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>]</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics/PhiSem_Real_Abst.html#PhiSem_Real_Abst.\&lt;phi&gt;AReal|const"><span>ℝ</span></a></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.COMMA|const"><span>❟</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>𝗏𝖺𝗅[</span></a></span><span class="free"><span>𝖺𝗋𝗀3</span></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.Val|const"><span>]</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics/PhiSem_Real_Abst.html#PhiSem_Real_Abst.\&lt;phi&gt;AReal|const"><span>ℝ</span></a></span><span>
  </span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.\&lt;phi&gt;Procedure_no_exception|const"><span>⟼</span></a></span><span>
   </span><span class="main"><span>(</span></span><span class="bound"><span>price'</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>i'</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>unlocked</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>Lg</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>L</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>growth</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.plus_class.plus|const"><span>+</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_growth|const"><span>fee_growth</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_factor|const"><span>fee_factor</span></a><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>δ</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>fee_protocol</span></span><span class="main"><span>,</span></span><span>
       </span><span class="free"><span>protocal_fees</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.plus_class.plus|const"><span>+</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Pool.html#Uniswap_Pool.Pool.\&lt;Delta&gt;protocal_fees|const"><span>Δprotocal_fees</span></a><span> </span><span class="free"><span>fee_protocol</span></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_factor|const"><span>fee_factor</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span>Uniswap_Pool</span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.COMMA|const"><span>❟</span></a></span><span>
     </span><span class="bound"><span>transfer_out</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span class="keyword1"><span>𝗏𝖺𝗅</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics/PhiSem_Real_Abst.html#PhiSem_Real_Abst.\&lt;phi&gt;AReal|const"><span>ℝ</span></a></span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.COMMA|const"><span>❟</span></a></span><span> </span><span class="bound"><span>transfer_in</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_System/Phi_BI.html#Phi_BI.\&lt;phi&gt;Type|const"><span>⦂</span></a></span><span> </span><span class="keyword1"><span>𝗏𝖺𝗅</span></span><span> </span><span class="main"><a class="entity_ref" href="../Phi_Semantics/PhiSem_Real_Abst.html#PhiSem_Real_Abst.\&lt;phi&gt;AReal|const"><span>ℝ</span></a></span><span>
   </span><span class="keyword1"><span>𝗌𝗎𝖻𝗃</span></span><span> </span><span class="bound"><span>price'</span></span><span> </span><span class="bound"><span>i'</span></span><span> </span><span class="bound"><span>transfer_out</span></span><span> </span><span class="bound"><span>transfer_in</span></span><span class="main"><span>.</span></span><span>
     </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less_eq|const"><span>≤</span></a></span><span> </span><span class="bound"><span>price'</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><span class="bound"><span>price'</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less_eq|const"><span>≤</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span>
     </span><span class="main"><span>(</span></span><span class="bound"><span>price'</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>price_limit</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.disj|const"><span>∨</span></a></span><span>
      </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.zero_class.zero|const"><span>0</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Orderings.html#Orderings.ord_class.less|const"><span>&lt;</span></a></span><span> </span><span class="free"><span>amount_specified</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><span class="free"><span>amount_specified</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.times_class.times|const"><span>*</span></a></span><span> </span><span class="main"><span>(</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.one_class.one|const"><span>1</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.minus_class.minus|const"><span>-</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee|const"><span>fee</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.fst|const"><span>fst</span></a><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.snd|const"><span>snd</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change|const"><span>reserve_change</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span class="main"><span>)</span></span><span>
       </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.uminus_class.uminus|const"><span>-</span></a></span><span> </span><span class="free"><span>amount_specified</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.snd|const"><span>snd</span></a><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.fst|const"><span>fst</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change|const"><span>reserve_change</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span>
     </span><span class="bound"><span>transfer_out</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.snd|const"><span>snd</span></a><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.fst|const"><span>fst</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change|const"><span>reserve_change</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span>
     </span><span class="bound"><span>transfer_in</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>if</span></a></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>then</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.fst|const"><span>fst</span></a><span> </span><span class="keyword1"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.If|const"><span>else</span></a></span><span> </span><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod.snd|const"><span>snd</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change|const"><span>reserve_change</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="bound"><span>price'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Fields.html#Fields.inverse_class.inverse_divide|const"><span>/</span></a></span><span> </span><span class="main"><span>(</span></span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.one_class.one|const"><span>1</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Groups.html#Groups.minus_class.minus|const"><span>-</span></a></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee|const"><span>fee</span></a><span class="main"><span>)</span></span><span>
  </span><span class="main"><a class="entity_ref" href="../Phi_System/Spec_Framework.html#Spec_Framework.\&lt;phi&gt;Procedure_no_exception|const"><span>⦄</span></a></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><span>swap_φapp</span><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Right now we have only verified the operation works correctly when the input arguments are valid as
</span><span>  specified in the three leading premises. When our underlying verification platform is completed,
</span><span>  we can in addition show a state revert would happen on invalid arguments so completes
</span><span>  this verification.
</span><span>
</span><span>The proof is given by theorem </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="Uniswap_Pool.html#Uniswap_Pool.Pool.swap_\&lt;phi&gt;app|fact"><span>Uniswap_Pool.Pool.swap_φapp</span></a><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>Argument </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>zeroForOne</span></span><span>›</span></span></span><span> indicates if the user wants to buy token1 using token0 or reversely.
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>amount_specified</span></span><span>›</span></span></span><span> is the amount that the user wants to pay if it is positive,
</span><span>or the amount that user wants to pay for if it is negative.
</span><span>As the transaction affects the price, the transaction terminates once the price reaches the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price_limit</span></span><span>›</span></span></span><span>
</span><span>or all the specified amount is processed.
</span><span>
</span><span>The initial state of the Uniswap pool contract is on price </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price</span></span><span>›</span></span></span><span>, tick </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>i</span></span><span>›</span></span></span><span>, liquidity </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>L</span></span><span>›</span></span></span><span>.
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>growth</span></span><span> </span><span class="main"><span>::</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.tick|type"><span>tick</span></a><span> </span><span class="main"><span>⇒</span></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.fee|type"><span>fee</span></a><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/Product_Type.html#Product_Type.prod|type"><span>×</span></a></span><span> </span><a class="entity_ref" href="Uniswap_Common.html#Uniswap_Common.fee|type"><span>fee</span></a><span>›</span></span></span><span> is the function from ticks to transaction fees that have been
</span><span>gained on the tick, in earning per unit of liquidity and for token0 and token1 respectively.
</span><span>Liquidity providers' yields are calculated by multiplying it by the amount of their liquidity.
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>fee_protocol</span></span><span>›</span></span></span><span> is the proportion of the contract owner's commission from the transaction fee.
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>protocal_fees</span></span><span>›</span></span></span><span> is the amount of the contract owner's commission that has been gained.
</span><span>
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>Lg</span></span><span>›</span></span></span><span> is a technical scaffold used in the implementation. So-called </span><span class="antiquoted"><span class="operator"><span>∗</span></span><span class="plain_text"><span>‹</span><span>Gross Liquidity</span><span>›</span></span></span><span>, it is
</span><span>a function from ticks to the total amount of liquidity providers' intervals that reference the tick.
</span><span>
</span><span>The above lemma specifies, after execution of the swap operation, the resulted price </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price'</span></span><span>›</span></span></span><span>
</span><span>will either reaches the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price_limit</span></span><span>›</span></span></span><span> (but never exceeds it), or, is exactly the one causing
</span><span>that the reserve change equals to the specified amount, with transaction fee considered.
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>reserve_change zeroForOne L price next_price ≡ (if zeroForOne then reserve_change' L next_price price else reserve_change' L price next_price)›</span></span></span><span>
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change|const"><span>reserve_change</span></a><span>›</span></span></span><span> is precisely the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.reserve_change&apos;|const"><span>reserve_change'</span></a><span>›</span></span></span><span> defined above but just considers the
</span><span>order of the prices (buying token1 using token0 causes the price decreases and reversely for the other side).
</span><span>
</span><span>The amount </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>transfer_in</span></span><span>›</span></span></span><span> that the user needs to pay and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>transfer_out</span></span><span>›</span></span></span><span> that Uniswap transfers to the user
</span><span>are the change of the reserves, with consideration of transaction fee.
</span><span>
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee|const"><span>fee</span></a><span>›</span></span><span> is the rate of the transaction fee.
</span><span>The record of the transaction fees is increased by </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>fee_growth zeroForOne fee_factor L price price'›</span></span></span><span>
</span><span>which gives for each tick the the fee per liquidity of the transaction moving the price from </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price</span></span><span>›</span></span></span><span> to </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>price'</span></span><span>›</span></span></span><span>.
</span><span>Note both </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>growth</span></span><span>›</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_growth|const"><span>fee_growth</span></a><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_factor|const"><span>fee_factor</span></a><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="free"><span>price'</span></span><span>›</span></span></span><span> are functions of ticks,
</span><span>and the addition is defined pointwisely.
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><span class="free"><span>Δprotocal_fees</span></span><span> </span><span class="free"><span>fee_protocol</span></span><span> </span><span class="free"><span>zeroForOne</span></span><span> </span><span class="free"><span>L</span></span><span> </span><span class="free"><span>price</span></span><span> </span><span class="free"><span>price'</span></span><span> </span><a class="entity_ref" href="Uniswap_SwapMath.html#Uniswap_SwapMath.fee_factor|const"><span>fee_factor</span></a><span>›</span></span></span><span> gives the fee of
</span><span>the contract owner's commission accordingly.
</span><span>
</span><span>To conclude, we have verified the proper behavior of the swap operation under valid input arguments.
</span><span>We haven't considered arithmetic overflow and precision error of fix-point arithmetic.
</span><span>The verification is done on an abstract specification level where we use variables instead of
</span><span>the exact solidity semantics to formalize the program.
</span><span>We will keep developing our framework to cover the complete Uniswap modules, complete argument domain,
</span><span>and concrete solidity semantics.</span><span>
</span><span>›</span></span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span></pre>
</body>

</html>