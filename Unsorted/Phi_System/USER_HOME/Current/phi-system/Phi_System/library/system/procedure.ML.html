<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹library/system/procedure.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹library/system/procedure.ML›</h1>
</div>

<pre class="source"><span class="comment1"><span>(* FILE: library/system/procedure.ML
   AUTHOR: Qiyuan Xu

   Defining procedures in IDE-CP.
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>PHI_PROCEDURE</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> procedure_kind </span><span class="main"><span>:</span></span><span> </span><span>string</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> cast_kind </span><span class="main"><span>:</span></span><span> </span><span>string</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> app_suffix </span><span class="main"><span>:</span></span><span> </span><span>string</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> compilation_suffix </span><span class="main"><span>:</span></span><span> </span><span>string</span><span>

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> simp_monads </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> define </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="comment1"><span>(*whether to define a new constant*)</span></span><span>
        </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Attrib.binding</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>local_theory</span><span> * </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>local_theory</span><span> * </span><span>thm</span><span>

  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>interface</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>{</span></span><span>name</span><span class="main"><span>:</span></span><span> </span><span>Binding.binding</span><span class="main"><span>,</span></span><span> </span><span>thm</span><span class="main"><span>:</span></span><span> </span><span>thm</span><span class="main"><span>}</span></span><span>
  </span><span class="comment1"><span>(*interfaces introduced in this given theory, excluding others inherited from parent theories*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> interfaces_of </span><span class="main"><span>:</span></span><span> </span><span>theory</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>interface</span></span><span> </span><span>Symtab.table</span><span>
  </span><span class="comment1"><span>(* (*procedures introduced in this given theory, excluding others inherited from parent theories*)
  val procedures_of : Context.generic -&gt; string list (*names*) *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> compilation_thm_of </span><span class="main"><span>:</span></span><span> </span><span>theory</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>string</span><span> </span><span class="comment1"><span>(*name*)</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> add_interface </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>interface</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>theory</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>theory</span><span>
  </span><span class="comment1"><span>(* val add_interface_command : (Binding.binding * string) * (string * string)
  * option -&gt; theory -&gt; theory *)</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Phi_Procedure</span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>PHI_PROCEDURE</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>
</span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Phi_Envir</span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>app_suffix</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"_φapp"</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>compilation_suffix</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"_def"</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>procedure_kind</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"φprocedure"</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cast_kind</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"φcast"</span></span><span>
</span><span class="comment1"><span>(* val compilation_thm = gen_get_thm compilation_suffix
fun compilation_thm_of ctx tm = compilation_thm ctx (term_name tm,
  Position.none) *)</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>interface</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>{</span></span><span>name</span><span class="main"><span>:</span></span><span> </span><span>Binding.binding</span><span class="main"><span>,</span></span><span> </span><span>thm</span><span class="main"><span>:</span></span><span> </span><span>thm</span><span class="main"><span>}</span></span><span>

</span><span class="comment1"><span>(*All interfaces to be exported in *a* theory*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Interfaces</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Theory_Data</span><span class="main"><span>(</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>T</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>interface</span></span><span> </span><span>Symtab.table</span><span> </span><span>Symtab.table</span><span class="main"><span>;</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>empty</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Symtab.empty</span><span class="main"><span>;</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>extend</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>I</span><span class="main"><span>;</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Symtab.merge</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>true</span><span class="main"><span>)</span></span><span>
</span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>interfaces_of</span></span><span> </span><span class="entity"><span>thy</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>the_default</span><span> </span><span>Symtab.empty</span><span> </span><span class="main"><span>(</span></span><span>Symtab.lookup</span><span> </span><span class="main"><span>(</span></span><span>Interfaces.get</span><span> </span><span class="entity"><span>thy</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Context.theory_long_name</span><span> </span><span class="entity"><span>thy</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>add_interface</span></span><span> </span><span class="entity"><span>intrf</span></span><span> </span><span class="entity"><span>thy</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>Interfaces.map</span><span> </span><span class="main"><span>(</span></span><span>Symtab.map_default</span><span>
    </span><span class="main"><span>(</span></span><span>Context.theory_long_name</span><span> </span><span class="entity"><span>thy</span></span><span class="main"><span>,</span></span><span> </span><span>Symtab.empty</span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>(</span></span><span>Symtab.insert</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>false</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Binding.name_of</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>#</span></span><span>name</span><span> </span><span class="entity"><span>intrf</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>intrf</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>thy</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>compilation_thm_of</span></span><span> </span><span class="entity"><span>thy</span></span><span> </span><span class="entity"><span>name</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>Global_Theory.get_thm</span><span> </span><span class="entity"><span>thy</span></span><span> </span><span class="main"><span>(</span></span><span>suffix</span><span> </span><span class="entity"><span>compilation_suffix</span></span><span> </span><span class="entity"><span>name</span></span><span class="main"><span>)</span></span><span>

</span><span class="comment1"><span>(* do not remove
(*All interfaces to be exported in *a* theory*)
structure Procedures = Generic_Data(
  type T = string list Symtab.table;
  val empty = Symtab.empty;
  val extend = I;
  val merge = Symtab.merge (K true)
)

val thy_name_of_ctxt = Context.theory_long_name o Context.the_theory

fun procedures_of ctxt =
  the_default [] (Symtab.lookup (Procedures.get ctxt) (thy_name_of_ctxt ctxt))
fun add_procedure name ctxt =
  Procedures.map (Symtab.map_default (thy_name_of_ctxt ctxt, [])
    (fn l =&gt; name :: l)) ctxt *)</span></span><span>

</span><span class="comment1"><span>(* do not remove

 fun add_interface_command ((name,const),tys) thy =
  let
    val ctxt = Proof_Context.init_global thy
          |&gt; Proof_Context.set_mode Proof_Context.mode_schematic

    (*prepare const*)
    fun prep_const const = case fastype_of const of Type ("fun", [T as Type("itself", _ ), _ ]) =&gt;
                                  prep_const (const $ Const("Pure.type", T))
                            | _ =&gt; const
    val const = Syntax.read_term_global thy const |&gt; prep_const
    val ty = case fastype_of const
               of Type ("fun", [ty, _ ]) =&gt; ty
                | ty =&gt; raise TYPE ("bad type: not a procedure", [ty], [const])
    val ty = HOLogic.strip_tupleT ty |&gt; List.last
    (* TODO: FIX ME *)
    (* val const = if is_TFree ty orelse is_TVar ty
                then Term.subst_atomic_types [(ty, typ void)] const (*set tail to void*)
                else const *)
    val const = Thm.cterm_of ctxt (Logic.varify_types_global const) |&gt; Drule.mk_term


    fun modify_tail ty =
      let
        val tys = HOLogic.strip_tupleT ty
      in
        if last tys = typ void then ty else HOLogic.mk_tupleT (tys @ [typ void])
      end
    val (ty_args,ty_rets) =
          the_default (TVar (("'a",0), @{sort lrep}), TVar (("'b",0), @{sort lrep}))
                      (Option.map (apply2 (modify_tail o Syntax.parse_typ ctxt)) tys)
    val goal = mk_Trueprop (Const (@{const_name Prog_Interface}, dummyT)
                $ Phi_Envir.mk_label (Binding.name_of name)
                $ Logic.mk_type ty_args
                $ Logic.mk_type ty_rets
                $ Var(("proc_or_func", 0), dummyT))
          |&gt; Syntax.check_term ctxt


    val thm = (const RS @{thm Prog_Interface_func})
          handle THM _ =&gt; const RS @{thm Prog_Interface_proc}
    val thm = thm RS Thm.trivial (Thm.cterm_of ctxt goal)


    val intrf = Thm.prop_of thm
    val _ = if null (Term.add_tfrees intrf []) andalso null (Term.add_tvars intrf []) then ()
            else raise TERM ("free type vars in an interface to be exported", [intrf])
  in
    add_interface {name = name, thm = thm} thy
  end
  *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>norm_def</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>m</span></span><span class="main"><span>,</span></span><span class="entity"><span>n</span></span><span class="main"><span>,</span></span><span class="entity"><span>instance</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>def</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
 </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>strip_abs_vars</span><span> </span><span class="main"><span>(</span></span><span>Logic.dest_equals</span><span> </span><span class="main"><span>(</span></span><span>Thm.concl_of</span><span> </span><span class="entity"><span>def</span></span><span class="main"><span>)</span></span><span> </span><span>|&gt;</span><span> </span><span class="main"><span>#</span></span><span class="inner_numeral"><span>2</span></span><span class="main"><span>)</span></span><span>
 </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ty_vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>take</span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>vars</span></span><span>
        </span><span>|&gt;</span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Pure.type"</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
 </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>normal_vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>take</span><span> </span><span class="entity"><span>n</span></span><span> </span><span class="main"><span>(</span></span><span>drop</span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>vars</span></span><span class="main"><span>)</span></span><span>
        </span><span>|&gt;</span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.var</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span class="inner_numeral"><span>0</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ty</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
 </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>insts</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ty_vars</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>normal_vars</span></span><span> </span><span>@</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Thm.cterm_of</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>instance</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
   </span><span> </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>a</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.combination</span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>a</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>Thm.reflexive</span><span> </span><span class="entity"><span>insts</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>def</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Raw_Simplifier.rewrite_rule</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms</span></span><span> </span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;V_simps|fact"><span>φV_simps</span></a><span class="main"><span>[</span></span><span class="operator"><span>folded</span></span><span> </span><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><span>atomize_eq</span></a></a></a></a></a></a></a></a></a></a></a></a><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span>
      </span><span>|&gt;</span><span> </span><span>Drule.eta_contraction_rule</span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.all</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span class="entity"><span>x</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span class="entity"><span>x</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>x</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>closure</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>substT</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
  </span><span class="comment1"><span>(*val tvars = Term.add_tvars f []
    val (subst,_) = Term.fold_types Term.declare_typ_names f Name.context
                    |&gt; pair []
                    |&gt; fold_rev (fn ((name,idx),sort) =&gt; fn (L,ctxt) =&gt;
                          Name.variant name ctxt
                            |&gt; apfst (fn name' =&gt;
                                  (((name,idx),sort), TFree (name',sort))::L)
                     ) tvars
    val f' = Term_Subst.instantiate (TVars.make subst, Vars.empty) f *)</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>trim</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;V_none|const"><span>φV_none</span></a><span>›</span></span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../../../../../HOL/HOL/Product_Type.html#Product_Type.unit|type"><span>unit</span></a><span> </span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;arg|type"><span>φarg</span></a><span>›</span></span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
          </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Term.is_open</span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="entity"><span>i</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>trim</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span class="main"><span>,</span></span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="entity"><span>i</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instance</span></span><span class="main"><span>,</span></span><span class="entity"><span>f''</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Procedure_Syntax.package_values</span></span><span> </span><span class="inner_quoted"><span>"𝖺𝗋𝗀"</span></span><span> </span><span>dummyT</span><span> </span><span>false</span><span> </span><span>NONE</span><span> </span><span class="entity"><span>f</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>trim</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>fold_aterms</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span>Var</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>insert</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span>
                             </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>I</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>f''</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>(</span></span><span>Var</span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
         </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>find_index</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="inner_numeral"><span>~1</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>Fail</span><span> </span><span class="inner_quoted"><span>"bug!"</span></span><span>
             </span><span class="main"><span>|</span></span><span> </span><span> </span><span class="entity"><span>j</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Bound</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>j</span></span><span> </span><span>+</span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>B</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span class="entity"><span>ty</span></span><span class="main"><span>,</span></span><span class="entity"><span>abst</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span>+</span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>X</span></span><span>

  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>abst</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span> </span><span class="entity"><span>f''</span></span><span>
      </span><span>|&gt;</span><span> </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars</span></span><span>
      </span><span>|&gt;</span><span> </span><span>TVars.fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>tfree</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"_"</span></span><span class="main"><span>,</span></span><span> </span><span>Type</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"itself"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span>Thm.typ_of</span><span> </span><span class="entity"><span>tfree</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>substT</span></span><span>
      </span><span>|&gt;</span><span> </span><span>pair</span><span> </span><span class="main"><span>(</span></span><span>TVars.size</span><span> </span><span class="entity"><span>substT</span></span><span class="main"><span>,</span></span><span> </span><span>length</span><span> </span><span class="entity"><span>vars</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>instance</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rule_proc_F</span></span><span> </span><span class="entity"><span>C</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Helper_Conv.hhf_concl_conv</span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span>
              </span><span class="main"><span>(</span></span><span>  </span><span class="entity"><span>Phi_Syntax.proc_monad_conv</span></span><span> </span><span class="entity"><span>C</span></span><span>
       </span><span>else_conv</span><span> </span><span class="entity"><span>Phi_Syntax.pending_construction_monad_conv</span></span><span> </span><span class="entity"><span>C</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>simp_monads</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sctxt</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Proc_Monad_SS.equip</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
     </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sequent'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>rule_proc_F</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Simplifier.rewrite</span></span><span> </span><span class="entity"><span>sctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>sequent'</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>importT_proc</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>f</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.concl_of</span><span> </span><span class="entity"><span>th</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>Phi_Syntax.dest_procedure</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instT</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Variable.importT_inst</span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>f</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>;</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>instT'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>TVars.map</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="main"><span>(</span></span><span>Thm.ctyp_of</span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>instT</span></span><span class="main"><span>;</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>instT'</span></span><span class="main"><span>,</span></span><span> </span><span>Vars.empty</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>instT'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>th'</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>gen_define</span></span><span> </span><span class="entity"><span>def_const</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>binding</span></span><span class="main"><span>,</span></span><span class="entity"><span>attrs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lthy0</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent0</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>substT</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>lthy</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>importT_proc</span></span><span> </span><span class="entity"><span>sequent0</span></span><span> </span><span class="entity"><span>lthy0</span></span><span>

   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>f</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.concl_of</span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>concl_of</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>Phi_Syntax.dest_procedure</span></span><span>

    </span><span class="comment1"><span>(*all variables are in the procedure body*)</span></span><span>
    </span><span class="comment1"><span>(*then f' is the standard form of a definition*)</span></span><span>
   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>arity_ins</span></span><span class="main"><span>,</span></span><span class="entity"><span>f'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>closure</span></span><span> </span><span class="entity"><span>lthy</span></span><span> </span><span class="entity"><span>substT</span></span><span> </span><span class="entity"><span>f</span></span><span>
                      </span><span>|&gt;</span><span> </span><span>apsnd</span><span> </span><span class="main"><span>(</span></span><span>Raw_Simplifier.rewrite_term</span><span> </span><span class="main"><span>(</span></span><span>Proof_Context.theory_of</span><span> </span><span class="entity"><span>lthy</span></span><span class="main"><span>)</span></span><span>
                                </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms</span></span><span> </span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.\&lt;phi&gt;V_simps|fact"><span>φV_simps</span></a><span class="main"><span>[</span></span><span class="operator"><span>folded</span></span><span> </span><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.atomize_eq|fact"><span>atomize_eq</span></a></a></a></a></a></a></a></a></a></a></a></a><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>

   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>def_binding</span></span><span class="main"><span>,</span></span><span class="entity"><span>proc_binding</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Binding.is_empty</span><span> </span><span class="entity"><span>binding</span></span><span>
                                     </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>binding</span></span><span class="main"><span>,</span></span><span class="entity"><span>binding</span></span><span class="main"><span>)</span></span><span>
                                     </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span>Binding.suffix_name</span><span> </span><span class="entity"><span>compilation_suffix</span></span><span> </span><span class="entity"><span>binding</span></span><span>
                                          </span><span class="main"><span>,</span></span><span>Binding.suffix_name</span><span> </span><span class="entity"><span>app_suffix</span></span><span> </span><span class="entity"><span>binding</span></span><span class="main"><span>)</span></span><span>

    </span><span class="comment1"><span>(*replace the procedure body in the procedural theorem to the newly defined constant*)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rename</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>def</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="entity"><span>rule_proc_F</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Conv.rewr_conv</span><span> </span><span class="main"><span>(</span></span><span>Thm.symmetric</span><span> </span><span class="entity"><span>def</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>

   </span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lthy</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>sequent''</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Binding.is_empty</span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="keyword1"><span class="keyword"><span>orelse</span></span></span><span> </span><span>not</span><span> </span><span class="entity"><span>def_const</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lthy</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>lthy</span></span><span>
            </span><span>|&gt;</span><span> </span><span>Local_Theory.define</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>binding</span></span><span class="main"><span>,</span></span><span> </span><span>NoSyn</span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>def_binding</span></span><span class="main"><span>,</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>f'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span>|-&gt;</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tm</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>def</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>lthy_x</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span class="entity"><span>lthy_x</span></span><span>
                  </span><span class="comment1"><span>(* |&gt; Local_Theory.background_theory
                        (Context.theory_map (add_procedure (Binding.name_of binding))) *)</span></span><span>
                  </span><span>|&gt;</span><span> </span><span>rpair</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>rename</span></span><span> </span><span class="entity"><span>lthy_x</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>norm_def</span></span><span> </span><span class="entity"><span>lthy_x</span></span><span> </span><span class="entity"><span>arity_ins</span></span><span> </span><span class="entity"><span>def</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
                </span><span class="main"><span>)</span></span><span>

  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>lthy</span></span><span> </span><span>|&gt;</span><span> </span><span>Local_Theory.notes_kind</span><span> </span><span class="entity"><span>procedure_kind</span></span><span>
                </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>proc_binding</span></span><span class="main"><span>,</span></span><span class="entity"><span>attrs</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="entity"><span>sequent''</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span>
          </span><span>|&gt;</span><span> </span><span>apfst</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>[</span></span><span class="entity"><span>sequent'4</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>sequent'4</span></span><span class="main"><span>)</span></span><span>
          </span><span>|&gt;</span><span> </span><span>swap</span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>define'</span></span><span> </span><span class="entity"><span>def_const</span></span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="entity"><span>stat</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Binding.is_empty_atts</span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>stat</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>gen_define</span></span><span> </span><span class="entity"><span>def_const</span></span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="entity"><span>stat</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>define</span></span><span> </span><span class="entity"><span>def_const</span></span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lthy</span></span><span class="main"><span>,</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>define'</span></span><span> </span><span class="entity"><span>def_const</span></span><span> </span><span class="entity"><span>binding</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lthy</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>simp_monads</span></span><span> </span><span class="entity"><span>lthy</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span></pre>
</body>

</html>